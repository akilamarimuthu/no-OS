/**
* Copyright 2015 - 2022 Analog Devices Inc.
* Released under the ADRV904X API license, for more information
* see the "LICENSE.pdf" file in this zip file.
*/

/**
 * \file adrv904x_carrier_reconfigure.c
 * \brief Contains ADRV904X Rx related private function implementations
 *
 * ADRV904X API Version: 2.9.0.4
 */

#include "../../private/include/adrv904x_carrier_reconfigure.h"
#include "../../private/include/adrv904x_rx.h"
#include "../../private/include/adrv904x_tx.h"
#include "../../private/bf/adrv904x_bf_cddc_funcs.h"
#include "../../private/bf/adrv904x_bf_cddc_hb_dpath.h"
#include "../../private/bf/adrv904x_bf_cduc_funcs.h"
#include "../../private/bf/adrv904x_bf_cduc_hb_dpath.h"
#include "../../private/bf/adrv904x_bf_channel_filter.h"
#include "../../private/bf/adrv904x_bf_jesd_common.h"

#define ADRV904X_SLOTS_PER_REGISTER  (8U)
#define ADRV904X_LAST_VALID_SLOT_SELECT_IN_CARRIER_MODE (31U)
#define ADRV904X_JESD_INT_INTERLEAVING_RATIO (4U)
#define ADRV904X_JESD_INTERFACE_MAX_FREQ_KHZ (500000U)
#define ADRV904X_JESD_XBAR_NUM_COLUMNS (16U)
#define ADRV904X_UNUSED (255U)

#define ADI_FILE    ADI_ADRV904X_FILE_PRIVATE_CARRIER_RECONFIGURE

static const int16_t adrv904x_cddc_coefs_5g_fs_122880_ibw_60000[] = {
       -30,     -6,     12,     14,      0,     -2,     11,     13,     -2,     -7,      9,     14,     -3,    -11,      6,     17,
        -2,    -15,      3,     19,      1,    -19,     -1,     22,      5,    -22,     -6,     24,     10,    -24,    -12,     26,
        16,    -25,    -20,     26,     24,    -25,    -28,     24,     33,    -22,    -37,     20,     42,    -17,    -46,     14,
        51,    -10,    -55,      5,     59,      0,    -63,     -6,     66,     13,    -69,    -21,     71,     29,    -73,    -38,
        74,     48,    -73,    -58,     72,     69,    -70,    -80,     66,     91,    -61,   -103,     55,    115,    -47,   -126,
        38,    138,    -26,   -149,     13,    159,      1,   -169,    -18,    178,     37,   -186,    -57,    193,     80,   -198,
      -105,    201,    132,   -203,   -161,    202,    193,   -198,   -228,    191,    265,   -181,   -305,    166,    349,   -147,
      -398,    122,    451,    -90,   -510,     50,    578,      2,   -656,    -69,    751,    157,   -869,   -279,   1028,    455,
     -1257,   -734,   1636,   1252,  -2423,  -2579,   5253,  14397
};

static const int16_t adrv904x_cddc_coefs_5g_fs_122880_ibw_70000[] = {
        33,      1,    -18,     -7,      4,    -11,    -14,      6,      2,    -17,     -3,     12,     -9,    -16,     11,      8,
       -20,     -4,     20,     -7,    -22,     15,     16,    -24,     -9,     29,     -4,    -31,     16,     25,    -29,    -16,
        38,      1,    -42,     16,     38,    -34,    -27,     47,      9,    -55,     13,     53,    -37,    -42,     57,     21,
       -70,      7,     72,    -38,    -61,     66,     37,    -86,     -4,     94,    -35,    -85,     73,     60,   -103,    -21,
       119,    -27,   -116,     78,     91,   -121,    -46,    149,    -13,   -154,     78,    131,   -139,    -82,    183,     11,
      -201,     73,    185,   -156,   -133,    223,     49,   -261,     58,    257,   -171,   -206,    273,    108,   -343,     27,
       363,   -184,   -320,    340,    209,   -466,    -32,    535,   -195,   -521,    448,    402,   -694,   -164,    892,   -202,
      -995,    704,    941,  -1365,   -630,   2291,   -206,  -4014,   3201,  16180
};

static const int16_t adrv904x_cddc_coefs_5g_fs_122880_ibw_80000[] = {
       -30,    -21,     16,     -7,     -3,      7,      0,    -11,     13,     -2,    -11,     11,      3,    -15,     12,      5,
       -18,     10,     10,    -21,      9,     15,    -23,      5,     20,    -24,      1,     26,    -24,     -5,     31,    -23,
       -12,     36,    -20,    -20,     41,    -16,    -30,     44,     -9,    -39,     45,      0,    -49,     45,     11,    -58,
        41,     24,    -66,     35,     39,    -73,     26,     54,    -78,     13,     70,    -79,     -3,     86,    -77,    -22,
       102,    -70,    -44,    115,    -59,    -69,    126,    -42,    -95,    132,    -20,   -122,    134,      7,   -150,    130,
        41,   -176,    118,     79,   -199,     99,    122,   -218,     70,    169,   -231,     31,    220,   -237,    -18,    272,
      -233,    -79,    326,   -216,   -154,    380,   -185,   -244,    432,   -134,   -352,    481,    -59,   -485,    526,     52,
      -652,    565,    216,   -877,    598,    476,  -1217,    624,    955,  -1859,    642,   2193,  -3891,    650,  17731
};

static const int16_t adrv904x_cddc_coefs_5g_fs_122880_ibw_90000[] = {
       -24,     23,     24,      0,     14,      3,     -6,     13,     -7,     -2,     12,    -13,      6,      6,    -15,     14,
        -3,    -12,     19,    -14,     -2,     18,    -22,     11,      9,    -25,     24,     -5,    -18,     31,    -22,     -3,
        28,    -35,     18,     13,    -37,     36,    -10,    -26,     46,    -34,     -2,     40,    -52,     28,     18,    -54,
        54,    -16,    -36,     66,    -51,     -1,     56,    -75,     42,     22,    -75,     79,    -26,    -48,     93,    -75,
         3,     76,   -106,     63,     27,   -104,    112,    -42,    -63,    130,   -109,     10,    102,   -150,     95,     31,
      -143,    161,    -66,    -82,    182,   -160,     23,    139,   -215,    143,     35,   -201,    236,   -106,   -109,    263,
      -242,     47,    197,   -321,    226,     39,   -299,    369,   -181,   -155,    414,   -401,     98,    310,   -542,    408,
        41,   -521,    689,   -374,   -270,    830,   -875,    266,    693,  -1373,   1179,     42,  -1775,   2940,  -2219,  -1999,
     18993
};

static const int16_t adrv904x_cddc_coefs_5g_fs_122880_ibw_100000[] = {
       -39,     -8,     10,    -12,     12,    -10,      5,      1,     -7,     10,    -10,      5,      2,    -10,     16,    -16,
        11,     -2,     -8,     16,    -19,     15,     -5,     -8,     19,    -25,     21,    -10,     -5,     20,    -29,     28,
       -16,     -2,     21,    -34,     35,    -25,      4,     19,    -37,     43,    -34,     12,     16,    -40,     52,    -45,
        23,     10,    -41,     59,    -58,     35,      1,    -40,     66,    -71,     51,    -11,    -35,     72,    -85,     69,
       -27,    -27,     75,    -99,     89,    -47,    -15,     75,   -112,    111,    -71,      3,     70,   -123,    135,   -100,
        27,     61,   -132,    160,   -134,     58,     44,   -136,    186,   -173,     97,     19,   -136,    212,   -217,    146,
       -17,   -128,    237,   -269,    207,    -66,   -110,    260,   -330,    286,   -136,    -77,    282,   -404,    391,   -236,
       -22,    300,   -500,    541,   -388,     72,    315,   -643,    784,   -655,    254,    326,   -913,   1293,  -1272,    730,
       333,  -1788,   3392,  -4844,   5856,  26550
};

static const int16_t adrv904x_cddc_coefs_5g_fs_15360_ibw_5000[] = {
        15,    -21,    -24,    -20,     -6,     10,     16,      6,    -11,    -21,    -12,      8,     24,     20,     -4,    -27,
       -28,     -3,     28,     37,     13,    -26,    -45,    -25,     20,     52,     40,    -11,    -57,    -55,     -3,     57,
        71,     21,    -53,    -86,    -44,     43,     99,     70,    -26,   -107,    -98,      1,    109,    127,     31,   -102,
      -154,    -70,     85,    177,    116,    -57,   -193,   -166,     15,    200,    219,     40,   -193,   -272,   -109,    169,
       321,    194,   -124,   -362,   -292,     54,    391,    406,     47,   -402,   -536,   -189,    386,    686,    388,   -330,
      -867,   -680,    209,   1110,   1159,     51,  -1521,  -2175,   -761,   2724,   6906,   9739
};

static const int16_t adrv904x_cddc_coefs_5g_fs_15360_ibw_10000[] = {
        42,    -21,    -38,     35,    -15,    -58,     60,      0,    -92,     81,     29,   -140,     96,     78,   -201,     99,
       151,   -273,     79,    258,   -352,     26,    407,   -433,    -78,    614,   -511,   -264,    912,   -579,   -604,   1398,
      -633,  -1336,   2468,   -667,  -4119,   9341,  21166
};

static const int16_t adrv904x_cddc_coefs_5g_fs_245760_ibw_200000[] = {
       -73,    -20,     22,    -22,     19,     -9,     -4,     16,    -24,     22,    -11,     -6,     23,    -33,     30,    -15,
        -8,     29,    -41,     37,    -17,    -13,     40,    -54,     47,    -20,    -17,     51,    -67,     57,    -22,    -25,
        67,    -85,     70,    -26,    -33,     83,   -104,     84,    -28,    -45,    106,   -129,    102,    -32,    -58,    131,
      -157,    122,    -34,    -76,    164,   -193,    146,    -37,    -98,    204,   -237,    176,    -38,   -127,    257,   -294,
       215,    -41,   -167,    328,   -371,    267,    -42,   -225,    431,   -485,    345,    -44,   -316,    596,   -670,    474,
       -45,   -483,    910,  -1040,    748,    -46,   -898,   1778,  -2210,   1785,    -46,  -4048,  19824
};

static const int16_t adrv904x_cddc_coefs_5g_fs_30720_ibw_25000[] = {
       -48,      5,      9,    -28,     44,    -48,     35,     -4,    -36,     72,    -87,     70,    -21,    -50,    117,   -153,
       137,    -64,    -49,    167,   -243,    241,   -145,    -26,    221,   -370,    406,   -293,     45,    273,   -552,    678,
      -570,    214,    316,   -863,   1227,  -1212,    693,    344,  -1777,   3370,  -4821,   5836,  26568
};

static const int16_t adrv904x_cddc_coefs_5g_fs_30720_ibw_5000[] = {
        22,     -1,     -2,     -5,     -8,    -10,    -12,    -11,     -9,     -6,     -2,      2,      5,      7,      7,      4,
         0,     -4,     -8,    -11,    -11,     -8,     -4,      2,      7,     11,     13,     12,      7,      1,     -6,    -12,
       -15,    -16,    -12,     -5,      3,     11,     17,     19,     17,     11,      1,     -9,    -17,    -22,    -22,    -17,
        -7,      5,     16,     24,     27,     24,     14,      1,    -13,    -25,    -31,    -31,    -23,     -9,      7,     23,
        34,     37,     32,     19,      1,    -19,    -35,    -43,    -42,    -30,    -11,     11,     32,     47,     50,     43,
        24,     -1,    -26,    -47,    -58,    -55,    -39,    -13,     17,     44,     63,     67,     56,     31,     -3,    -37,
       -64,    -77,    -73,    -51,    -16,     24,     61,     84,     89,     72,     38,     -6,    -51,    -86,   -103,    -95,
       -65,    -18,     36,     83,    113,    117,     94,     48,    -12,    -72,   -118,   -138,   -126,    -84,    -20,     52,
       115,    154,    158,    125,     61,    -21,   -103,   -164,   -189,   -171,   -111,    -22,     78,    165,    217,    221,
       172,     79,    -38,   -153,   -240,   -274,   -245,   -156,    -23,    125,    254,    331,    335,    258,    113,    -72,
      -255,   -394,   -450,   -402,   -252,    -24,    236,    468,    615,    629,    489,    206,   -175,   -579,   -914,  -1087,
     -1019,   -666,    -24,    858,   1892,   2953,   3908,   4629,   5016
};

static const int16_t adrv904x_cddc_coefs_5g_fs_30720_ibw_10000[] = {
       -25,      1,     10,     17,     16,      7,     -3,     -6,      1,     10,     13,      6,     -6,    -13,     -7,      7,
        16,     11,     -4,    -16,    -14,      2,     17,     18,      2,    -17,    -22,     -6,     17,     26,     11,    -14,
       -29,    -17,     11,     31,     24,     -6,    -33,    -30,      0,     33,     37,      7,    -32,    -44,    -16,     29,
        49,     25,    -24,    -54,    -36,     17,     57,     47,     -7,    -58,    -58,     -4,     57,     69,     18,    -53,
       -79,    -33,     46,     88,     50,    -36,    -94,    -68,     22,     98,     87,     -5,    -98,   -105,    -15,     94,
       123,     39,    -85,   -138,    -66,     72,    151,     95,    -53,   -161,   -127,     28,    166,    159,      4,   -165,
      -191,    -41,    157,    222,     85,   -141,   -251,   -135,    116,    277,    191,    -80,   -298,   -254,     32,    312,
       323,     31,   -317,   -399,   -112,    310,    483,    216,   -288,   -579,   -352,    245,    691,    535,   -168,   -833,
      -804,     34,   1038,   1253,    229,  -1414,  -2234,   -934,   2588,   6925,   9898
};

static const int16_t adrv904x_cddc_coefs_5g_fs_30720_ibw_15000[] = {
        34,      2,    -26,    -20,     12,      9,    -26,    -24,     19,     23,    -27,    -36,     23,     41,    -25,    -54,
        20,     62,    -18,    -75,     11,     87,     -3,   -100,     -8,    112,     22,   -125,    -39,    137,     59,   -148,
       -83,    157,    111,   -164,   -143,    169,    180,   -170,   -222,    167,    268,   -158,   -321,    143,    380,   -120,
      -447,     88,    523,    -42,   -611,    -19,    716,    105,   -846,   -224,   1015,    400,  -1256,   -682,   1646,   1204,
     -2443,  -2536,   5281,  14360
};

static const int16_t adrv904x_cddc_coefs_5g_fs_30720_ibw_20000[] = {
       -34,     17,     32,    -11,      8,     32,    -21,     -4,     40,    -26,    -18,     52,    -25,    -36,     64,    -17,
       -58,     75,     -3,    -85,     82,     21,   -114,     83,     54,   -145,     73,     98,   -174,     50,    152,   -199,
        12,    215,   -213,    -47,    286,   -213,   -128,    362,   -191,   -236,    440,   -139,   -378,    517,    -47,   -562,
       588,    108,   -811,    651,    368,  -1181,    701,    856,  -1855,    736,   2112,  -3919,    754,  17674
};

static const int16_t adrv904x_cddc_coefs_5g_fs_491520_ibw_400000[] = {
       -73,    -20,     22,    -22,     19,     -9,     -4,     16,    -24,     22,    -11,     -6,     23,    -33,     30,    -15,
        -8,     29,    -41,     37,    -17,    -13,     40,    -54,     47,    -20,    -17,     51,    -67,     57,    -22,    -25,
        67,    -85,     70,    -26,    -33,     83,   -104,     84,    -28,    -45,    106,   -129,    102,    -32,    -58,    131,
      -157,    122,    -34,    -76,    164,   -193,    146,    -37,    -98,    204,   -237,    176,    -38,   -127,    257,   -294,
       215,    -41,   -167,    328,   -371,    267,    -42,   -225,    431,   -485,    345,    -44,   -316,    596,   -670,    474,
       -45,   -483,    910,  -1040,    748,    -46,   -898,   1778,  -2210,   1785,    -46,  -4048,  19824
};

static const int16_t adrv904x_cddc_coefs_5g_fs_61440_ibw_30000[] = {
       -30,      7,     28,     18,     -8,     -3,     23,     15,    -18,    -13,     23,     21,    -23,    -25,     25,     31,
       -24,    -37,     24,     45,    -22,    -53,     20,     61,    -17,    -70,     12,     79,     -5,    -89,     -3,     98,
        12,   -108,    -24,    117,     38,   -125,    -54,    133,     72,   -140,    -92,    145,    116,   -149,   -142,    151,
       171,   -150,   -203,    147,    238,   -140,   -277,    129,    320,   -113,   -368,     91,    421,    -62,   -480,     24,
       549,     25,   -628,    -90,    724,    177,   -844,   -297,   1004,    472,  -1235,   -751,   1615,   1269,  -2404,  -2596,
      5234,  14414
};

static const int16_t adrv904x_cddc_coefs_5g_fs_61440_ibw_40000[] = {
       -16,     34,     25,    -10,      7,     13,    -18,      4,     17,    -22,      1,     24,    -24,     -4,     31,    -25,
       -11,     40,    -25,    -21,     48,    -23,    -32,     56,    -17,    -46,     63,     -8,    -62,     68,      4,    -79,
        70,     21,    -97,     69,     42,   -116,     63,     67,   -133,     52,     97,   -149,     34,    131,   -161,      8,
       169,   -169,    -26,    210,   -170,    -70,    254,   -163,   -125,    298,   -145,   -193,    343,   -113,   -275,    388,
       -63,   -375,    430,     11,   -498,    468,    118,   -656,    503,    278,   -872,    532,    534,  -1204,    554,   1007,
     -1838,    570,   2238,  -3861,    578,  17769
};

static const int16_t adrv904x_cddc_coefs_5g_fs_61440_ibw_50000[] = {
        44,      3,     -9,     17,    -23,     22,    -14,      0,     15,    -27,     30,    -21,      1,     22,    -41,     47,
       -37,     12,     21,    -50,     64,    -56,     25,     20,    -63,     87,    -83,     47,     11,    -71,    112,   -116,
        77,     -4,    -78,    140,   -158,    119,    -32,    -77,    170,   -209,    176,    -74,    -67,    199,   -272,    253,
      -137,    -42,    228,   -350,    358,   -233,      6,    253,   -453,    511,   -385,     96,    275,   -603,    759,   -653,
       275,    292,   -879,   1274,  -1274,    751,    302,  -1760,   3379,  -4851,   5879,  26520
};

static const int16_t adrv904x_cddc_coefs_5g_fs_7680_ibw_5000[] = {
        55,      1,    -72,     94,      6,   -154,    158,     63,   -309,    247,    178,   -548,    337,    417,   -936,    424,
       901,  -1649,    490,   2177,  -3763,    527,  17778
};

static const int16_t adrv904x_cddc_coefs_high_bw_5g_fs_122880_ibw_60000[] = {
       -41,    -51,     -8,     12,     13,    -17,     -6,     12,     11,    -16,    -10,     13,     14,    -15,    -15,     14,
        19,    -14,    -21,     12,     24,    -11,    -27,      9,     30,     -6,    -33,      3,     36,      0,    -39,     -5,
        41,      9,    -43,    -14,     45,     20,    -46,    -26,     46,     33,    -46,    -40,     45,     47,    -43,    -55,
        40,     63,    -37,    -71,     32,     78,    -26,    -86,     18,     93,    -10,   -100,      0,    107,     11,   -112,
       -23,    117,     36,   -121,    -51,    123,     66,   -124,    -83,    124,    101,   -121,   -120,    117,    140,   -110,
      -160,    102,    181,    -90,   -203,     76,    225,    -58,   -247,     37,    270,    -13,   -292,    -16,    314,     49,
      -336,    -88,    357,    133,   -377,   -185,    396,    245,   -415,   -316,    432,    401,   -447,   -504,    462,    634,
      -474,   -804,    485,   1039,   -494,  -1396,    501,   2019,   -506,  -3436,    509,  10417,  15874
};

static const int16_t adrv904x_cddc_coefs_lte_fs_15360_ibw_5000[] = {
         6,      1,     -5,    -13,    -18,    -15,     -5,      6,     10,      4,     -7,    -13,     -8,      5,     15,     13,
        -2,    -16,    -18,     -3,     16,     23,     10,    -14,    -28,    -18,      9,     31,     28,     -1,    -32,    -37,
        -9,     30,     46,     22,    -24,    -53,    -37,     14,     57,     53,      0,    -57,    -69,    -19,     52,     83,
        42,    -41,    -94,    -67,     23,    100,     93,      2,    -99,   -119,    -35,     89,    143,     72,    -69,   -160,
      -115,     38,    169,    159,      5,   -167,   -203,    -59,    151,    244,    124,   -119,   -276,   -198,     67,    297,
       280,      7,   -300,   -366,   -105,    281,    454,    231,   -231,   -540,   -391,    141,    620,    595,      8,   -691,
      -869,   -253,    750,   1280,    694,   -795,  -2060,  -1731,    822,   4869,   8587,  10091
};

static const int16_t adrv904x_cddc_coefs_lte_fs_15360_ibw_10000[] = {
       -26,    -24,     27,      8,    -39,     31,     36,    -70,     17,     88,    -95,    -29,    160,    -97,   -120,    238,
       -49,   -260,    298,     75,   -445,    302,    307,   -659,    196,    687,   -874,   -114,   1302,  -1060,   -877,   2531,
     -1186,  -3752,   9569,  20614
};

static const int16_t adrv904x_cddc_coefs_lte_fs_30720_ibw_5000[] = {
         1,      1,      1,      1,      0,     -1,     -2,     -3,     -5,     -6,     -7,     -8,     -7,     -6,     -4,     -2,
         0,      2,      3,      4,      3,      2,      0,     -2,     -3,     -4,     -4,     -3,     -2,      1,      3,      4,
         5,      5,      3,      1,     -2,     -4,     -6,     -6,     -5,     -3,      0,      3,      6,      7,      7,      5,
         2,     -2,     -6,     -8,     -9,     -8,     -5,      0,      4,      8,     10,     10,      8,      4,     -2,     -7,
       -11,    -13,    -11,     -7,     -1,      5,     11,     14,     15,     12,      6,     -2,     -9,    -15,    -17,    -16,
       -11,     -3,      6,     14,     19,     20,     16,      9,     -1,    -11,    -19,    -23,    -22,    -15,     -5,      7,
        17,     25,     27,     22,     13,      0,    -14,    -24,    -30,    -29,    -21,     -8,      7,     22,     32,     35,
        30,     18,      1,    -16,    -31,    -39,    -38,    -29,    -12,      8,     27,     41,     45,     40,     25,      3,
       -20,    -39,    -50,    -50,    -38,    -17,      9,     34,     52,     58,     52,     33,      6,    -24,    -49,    -64,
       -65,    -50,    -24,      9,     42,     65,     75,     67,     44,      9,    -29,    -62,    -81,    -83,    -66,    -32,
        10,     52,     83,     96,     87,     58,     14,    -35,    -78,   -104,   -108,    -86,    -44,     11,     65,    106,
       124,    115,     78,     21,    -43,   -100,   -136,   -141,   -115,    -60,     11,     83,    139,    165,    153,    106,
        31,    -54,   -131,   -181,   -191,   -157,    -85,     11,    110,    188,    227,    214,    150,     48,    -72,   -182,
      -256,   -275,   -230,   -127,     12,    158,    277,    340,    326,    235,     80,   -107,   -284,   -409,   -449,   -385,
      -222,     12,    269,    491,    622,    619,    464,    172,   -210,   -607,   -929,  -1084,  -1000,   -634,     12,    891,
      1913,   2958,   3896,   4602,   4981
};

static const int16_t adrv904x_cddc_coefs_lte_fs_30720_ibw_10000[] = {
        -9,    -10,     -7,      2,     13,     18,     14,      3,     -6,     -7,      3,     14,     16,      6,     -9,    -16,
        -9,      9,     22,     17,     -3,    -22,    -23,     -3,     23,     31,     12,    -20,    -37,    -23,     14,     42,
        35,     -4,    -43,    -48,     -9,     41,     60,     26,    -34,    -69,    -45,     22,     76,     66,     -4,    -77,
       -87,    -20,     71,    106,     49,    -57,   -121,    -82,     35,    130,    117,     -3,   -130,   -151,    -38,    119,
       183,     87,    -96,   -208,   -143,     57,    223,    203,     -2,   -224,   -265,    -69,    208,    323,    157,   -169,
      -375,   -262,    102,    414,    384,     -1,   -434,   -524,   -142,    426,    685,    345,   -377,   -877,   -644,    259,
      1131,   1131,     -1,  -1552,  -2158,   -710,   2764,   6900,   9693
};

static const int16_t adrv904x_cddc_coefs_lte_fs_30720_ibw_15000[] = {
         7,      2,    -18,    -31,    -11,     18,     10,    -24,    -21,     25,     32,    -23,    -47,     17,     63,     -5,
       -79,    -13,     94,     38,   -104,    -71,    108,    110,   -104,   -155,     88,    205,    -57,   -255,     10,    304,
        56,   -346,   -144,    378,    255,   -392,   -392,    382,    557,   -339,   -758,    248,   1005,    -85,  -1329,   -200,
      1802,    741,  -2680,  -2110,   5592,  13985
};

static const int16_t adrv904x_cddc_coefs_lte_fs_30720_ibw_20000[] = {
       -24,    -29,     15,     13,    -31,      8,     36,    -41,    -15,     67,    -35,    -59,     94,     -1,   -119,     99,
        70,   -181,     61,    175,   -219,    -38,    302,   -200,   -207,    416,    -87,   -441,    471,    157,   -718,    402,
       574,  -1003,    107,   1250,  -1250,   -670,   2554,  -1419,  -3588,   9667,  20366
};

static const int16_t adrv904x_cddc_coefs_lte_fs_7680_ibw_5000[] = {
        14,    -25,    -55,     38,     20,    -94,     61,     83,   -178,     58,    202,   -290,      5,    405,   -418,   -141,
       729,   -549,   -464,   1268,   -661,  -1208,   2410,   -737,  -4034,   9360,  21081
};

static const int16_t adrv904x_cddc_coefs_lte_iot_fs_15360_ibw_10000[] = {
        10,      0,    -29,    -17,      9,    -10,    -10,     17,     -8,    -14,     23,     -7,    -22,     30,     -4,    -32,
        36,      2,    -45,     42,     11,    -60,     48,     23,    -78,     51,     40,    -99,     52,     62,   -121,     50,
        89,   -146,     43,    124,   -172,     30,    167,   -199,      8,    218,   -227,    -23,    281,   -254,    -67,    358,
      -280,   -130,    452,   -305,   -217,    574,   -327,   -343,    738,   -346,   -536,    981,   -362,   -865,   1404,   -373,
     -1567,   2406,   -380,  -4305,   9214,  21463
};

static const int16_t adrv904x_cddc_coefs_lte_iot_fs_30720_ibw_20000[] = {
        19,     30,     -1,    -15,     13,      5,    -20,     12,     14,    -27,      6,     28,    -32,     -6,     44,    -32,
       -26,     61,    -23,    -52,     73,     -2,    -84,     76,     32,   -117,     65,     80,   -146,     34,    139,   -161,
       -19,    203,   -156,    -98,    265,   -120,   -201,    315,    -45,   -324,    338,     78,   -463,    319,    259,   -607,
       235,    513,   -746,     53,    871,   -869,   -302,   1424,   -965,  -1065,   2564,  -1027,  -3896,   9505,  20797
};

static const int16_t adrv904x_cddc_coefs_high_bw_5g_fs_122880_ibw_100000[] = {
        52,     17,    -16,     16,    -13,      8,     -1,     -6,     11,    -13,      9,     -1,     -8,     16,    -19,     16,
        -7,     -5,     16,    -21,     20,    -10,     -4,     18,    -27,     27,    -17,      1,     17,    -30,     33,    -24,
         6,     16,    -34,     41,    -34,     14,     12,    -36,     49,    -44,     24,      7,    -37,     56,    -57,     36,
        -2,    -36,     63,    -69,     51,    -14,    -31,     68,    -83,     69,    -29,    -23,     71,    -96,     88,    -49,
       -11,     70,   -109,    110,    -72,      6,     66,   -119,    134,   -101,     30,     56,   -128,    158,   -134,     60,
        40,   -132,    184,   -173,     99,     15,   -131,    209,   -217,    148,    -20,   -123,    233,   -268,    209,    -70,
      -105,    257,   -328,    287,   -139,    -73,    278,   -402,    392,   -239,    -18,    296,   -498,    541,   -391,     76,
       311,   -641,    784,   -657,    258,    322,   -910,   1292,  -1274,    734,    329,  -1784,   3390,  -4846,   5859,  26545
};

static const int16_t adrv904x_cduc_coefs_5g_fs_122880_ibw_60000[] = {
        -4,   -113,    139,    -62,    -37,     33,     27,    -22,    -25,     16,     26,    -12,    -27,      8,     28,     -5,
       -29,      1,     31,      2,    -32,     -6,     33,     10,    -33,    -14,     33,     19,    -33,    -23,     32,     28,
       -31,    -32,     30,     37,    -27,    -42,     24,     47,    -21,    -51,     16,     55,    -11,    -59,      6,     63,
         1,    -66,     -7,     69,     15,    -71,    -23,     72,     32,    -72,    -41,     71,     50,    -69,    -60,     66,
        70,    -62,    -80,     57,     90,    -50,   -100,     42,    109,    -33,   -118,     22,    126,    -10,   -133,     -4,
       140,     19,   -145,    -35,    149,     53,   -152,    -71,    152,     91,   -150,   -113,    147,    135,   -141,   -157,
       133,    181,   -121,   -205,    107,    229,    -89,   -254,     68,    279,    -43,   -304,     13,    328,     21,   -352,
       -61,    375,    107,   -397,   -160,    419,    222,   -439,   -295,    457,    381,   -474,   -487,    490,    619,   -504,
      -791,    516,   1029,   -525,  -1388,    533,   2012,   -539,  -3432,    542,  10416,  15841
};

static const int16_t adrv904x_cduc_coefs_5g_fs_122880_ibw_70000[] = {
        13,   -116,    118,    -64,    -20,     46,     -3,    -36,     14,     28,    -24,    -19,     31,      8,    -35,      6,
        34,    -19,    -28,     32,     17,    -40,     -1,     43,    -17,    -39,     34,     28,    -47,    -10,     54,    -12,
       -52,     35,     41,    -54,    -22,     66,     -4,    -68,     33,     58,    -59,    -37,     78,      7,    -85,     27,
        79,    -62,    -58,     89,     24,   -104,     17,    103,    -61,    -84,     99,     48,   -124,      0,    131,    -55,
      -117,    106,     80,   -145,    -25,    164,    -41,   -157,    109,    122,   -166,    -61,    201,    -18,   -206,    105,
       177,   -185,   -112,    244,     19,   -270,     91,    252,   -203,   -187,    297,     79,   -355,     62,    360,   -218,
      -303,    366,    180,   -481,      3,    535,   -230,   -506,    477,    375,   -712,   -129,    896,   -238,   -983,    735,
       915,  -1386,   -596,   2297,   -243,  -4004,   3234,  16156
};

static const int16_t adrv904x_cduc_coefs_5g_fs_122880_ibw_80000[] = {
       -52,      1,     47,    -94,    104,    -65,      8,     24,    -11,    -21,     34,    -10,    -23,     29,     -1,    -29,
        28,      6,    -34,     24,     14,    -38,     20,     22,    -41,     14,     31,    -43,      6,     40,    -43,     -3,
        48,    -41,    -14,     56,    -36,    -26,     62,    -29,    -39,     66,    -19,    -53,     68,     -6,    -66,     66,
        10,    -79,     61,     27,    -89,     53,     47,    -98,     40,     67,   -103,     23,     88,   -103,      1,    108,
       -99,    -23,    126,    -90,    -52,    142,    -74,    -82,    153,    -52,   -114,    159,    -24,   -147,    159,     11,
      -179,    151,     52,   -208,    134,     99,   -233,    107,    151,   -252,     68,    207,   -263,     18,    265,   -263,
       -45,    325,   -251,   -123,    386,   -222,   -216,    444,   -174,   -329,    499,    -99,   -467,    550,     12,   -640,
       595,    178,   -872,    632,    441,  -1219,    661,    923,  -1868,    681,   2166,  -3906,    691,  17709
};

static const int16_t adrv904x_cduc_coefs_5g_fs_122880_ibw_90000[] = {
       -60,     38,    -22,    -11,     49,    -75,     77,    -55,     21,      5,    -10,     -6,     28,    -40,     32,     -7,
       -19,     27,    -13,    -14,     35,    -34,     11,     20,    -38,     28,      3,    -34,     43,    -23,    -14,     43,
       -43,     12,     30,    -52,     40,      2,    -44,     58,    -31,    -19,     58,    -58,     17,     39,    -70,     53,
         2,    -59,     77,    -42,    -25,     77,    -78,     24,     50,    -93,     72,      1,    -77,    102,    -56,    -32,
       102,   -104,     32,     66,   -123,     96,      1,   -102,    136,    -76,    -41,    136,   -139,     44,     87,   -164,
       129,      0,   -136,    183,   -103,    -55,    184,   -189,     61,    119,   -225,    178,      0,   -189,    256,   -145,
       -78,    260,   -270,     87,    172,   -328,    261,     -1,   -282,    386,   -221,   -119,    406,   -427,    140,    280,
      -544,    441,     -1,   -499,    701,   -413,   -231,    817,   -897,    308,    659,  -1371,   1210,     -1,  -1748,   2947,
     -2256,  -1958,  18975
};

static const int16_t adrv904x_cduc_coefs_5g_fs_122880_ibw_100000[] = {
         0,    -63,     51,    -59,     59,    -50,     32,    -10,    -11,     26,    -30,     24,     -9,     -9,     23,    -29,
        25,    -12,     -6,     23,    -32,     30,    -17,     -3,     23,    -35,     35,    -23,      2,     21,    -38,     42,
       -31,      8,     18,    -40,     48,    -40,     17,     14,    -41,     55,    -50,     26,      7,    -40,     60,    -60,
        38,     -1,    -37,     65,    -71,     51,    -12,    -33,     68,    -81,     66,    -26,    -25,     70,    -92,     82,
       -42,    -15,     69,   -101,     99,    -61,     -1,     65,   -110,    117,    -83,     17,     58,   -116,    135,   -107,
        39,     47,   -120,    154,   -135,     66,     31,   -121,    173,   -166,     98,      9,   -118,    192,   -200,    137,
       -21,   -110,    209,   -239,    185,    -59,    -95,    226,   -284,    243,   -111,    -71,    241,   -337,    317,   -180,
       -34,    255,   -402,    416,   -278,     23,    266,   -490,    558,   -426,    119,    276,   -625,    793,   -688,    300,
       282,   -886,   1293,  -1298,    774,    286,  -1754,   3382,  -4862,   5895,  26502
};

static const int16_t adrv904x_cduc_coefs_5g_fs_15360_ibw_5000[] = {
        40,   -205,     88,     82,     18,    -39,    -60,    -32,     24,     62,     48,    -12,    -66,    -65,     -3,     68,
        84,     22,    -67,   -103,    -46,     60,    121,     75,    -46,   -136,   -108,     24,    148,    146,      7,   -152,
      -185,    -49,    147,    226,    101,   -131,   -265,   -165,     99,    299,    241,    -50,   -326,   -329,    -22,    342,
       429,    123,   -340,   -544,   -260,    314,    678,    451,   -252,   -844,   -732,    126,   1071,   1198,    134,  -1468,
     -2200,   -842,   2659,   6914,   9814
};

static const int16_t adrv904x_cduc_coefs_5g_fs_15360_ibw_10000[] = {
      -102,    129,    -92,     -4,     83,    -57,    -40,    103,    -41,    -80,    123,    -14,   -128,    135,     30,   -181,
       131,     95,   -234,    103,    181,   -279,     44,    286,   -305,    -55,    407,   -299,   -203,    536,   -243,   -412,
       665,   -110,   -702,    785,    145,  -1125,    885,    646,  -1861,    957,   1934,  -3989,    994,  17544
};

static const int16_t adrv904x_cduc_coefs_5g_fs_245760_ibw_200000[] = {
       -63,     45,    -46,     36,    -15,    -13,     41,    -61,     67,    -57,     33,     -4,    -21,     33,    -26,      4,
        27,    -56,     71,    -64,     38,      1,    -39,     63,    -62,     34,     10,    -57,     89,    -92,     63,    -10,
       -49,     93,   -104,     76,    -16,    -56,    113,   -134,    108,    -40,    -47,    122,   -157,    135,    -61,    -43,
       139,   -191,    177,    -95,    -28,    150,   -225,    223,   -136,     -9,    163,   -270,    284,   -194,     22,    173,
      -322,    363,   -271,     67,    184,   -392,    475,   -387,    141,    191,   -494,    648,   -575,    267,    197,   -670,
       971,   -950,    541,    201,  -1093,   1847,  -2126,   1580,    204,  -4249,  19901
};

static const int16_t adrv904x_cduc_coefs_5g_fs_30720_ibw_25000[] = {
       -27,     90,    -70,     87,    -65,     31,     16,    -57,     78,    -70,     33,     23,    -76,    107,    -98,     48,
        27,   -102,    146,   -136,     71,     31,   -134,    196,   -188,    103,     34,   -175,    264,   -258,    147,     37,
      -230,    356,   -355,    211,     39,   -309,    493,   -505,    311,     41,   -437,    724,   -766,    496,     42,   -693,
      1221,  -1375,    972,     43,  -1558,   3308,  -4938,   6093,  26258
};

static const int16_t adrv904x_cduc_coefs_5g_fs_30720_ibw_5000[] = {
       140,   -189,    -73,     -8,     25,     38,     38,     29,     16,      2,    -12,    -23,    -29,    -28,    -21,    -10,
         4,     18,     28,     32,     28,     18,      3,    -14,    -28,    -36,    -36,    -27,    -11,      8,     27,     40,
        44,     37,     22,      0,    -23,    -42,    -51,    -49,    -34,    -11,     17,     42,     57,     60,     48,     24,
        -7,    -38,    -62,    -71,    -64,    -41,     -7,     31,     63,     81,     81,     61,     25,    -18,    -60,    -88,
       -97,    -83,    -48,      1,     51,     92,    113,    107,     75,     23,    -37,    -91,   -126,   -132,   -106,    -54,
        14,     83,    135,    157,    142,     92,     17,    -66,   -138,   -180,   -181,   -138,    -59,     39,    133,    200,
       223,    193,    114,      3,   -116,   -215,   -268,   -260,   -187,    -63,     85,    223,    317,    341,    284,    152,
       -29,   -219,   -372,   -448,   -421,   -286,    -66,    195,    440,    605,    640,    518,    247,   -132,   -544,   -896,
     -1090,  -1042,   -703,    -68,    819,   1866,   2947,   3923,   4661,   5058
};

static const int16_t adrv904x_cduc_coefs_5g_fs_30720_ibw_10000[] = {
      -141,    164,     33,    -33,    -42,    -13,     25,     42,     27,     -9,    -34,    -28,      6,     38,     38,      4,
       -35,    -43,    -10,     35,     51,     21,    -31,    -57,    -31,     27,     63,     43,    -19,    -67,    -55,     10,
        70,     68,      1,    -71,    -81,    -16,     69,     94,     32,    -64,   -107,    -51,     56,    118,     72,    -44,
      -127,    -95,     28,    133,    120,     -7,   -136,   -145,    -19,    134,    171,     49,   -127,   -196,    -85,    114,
       220,    125,    -94,   -241,   -171,     66,    259,    222,    -28,   -272,   -278,    -21,    279,    340,     83,   -278,
      -408,   -162,    265,    484,    262,   -239,   -571,   -393,    192,    675,    571,   -114,   -809,   -833,    -22,   1007,
      1274,    284,  -1376,  -2247,   -987,   2544,   6930,   9948
};

static const int16_t adrv904x_cduc_coefs_5g_fs_30720_ibw_15000[] = {
        80,   -170,     65,     39,    -46,    -46,     27,     47,    -21,    -54,     13,     60,     -6,    -67,     -3,     73,
        13,    -79,    -25,     83,     38,    -86,    -53,     88,     70,    -87,    -88,     84,    107,    -77,   -128,     68,
       148,    -54,   -169,     37,    190,    -15,   -210,    -12,    228,     44,   -244,    -81,    257,    123,   -266,   -172,
       270,    227,   -269,   -288,    259,    357,   -241,   -435,    212,    522,   -170,   -622,    109,    738,    -23,   -880,
       -98,   1061,    277,  -1313,   -563,   1715,   1090,  -2522,  -2429,   5371,  14261
};

static const int16_t adrv904x_cduc_coefs_5g_fs_30720_ibw_20000[] = {
       -82,     71,    -23,    -59,    109,    -84,     12,     33,     -1,    -67,     89,    -28,    -53,     62,     18,    -98,
        79,     29,   -107,     59,     72,   -135,     46,    105,   -143,     10,    152,   -150,    -32,    193,   -138,    -91,
       236,   -113,   -160,    269,    -64,   -242,    291,      8,   -332,    291,    109,   -427,    265,    243,   -523,    200,
       418,   -615,     81,    647,   -698,   -122,    964,   -769,   -477,   1465,   -822,  -1222,   2548,   -856,  -4018,   9432,
     20978
};

static const int16_t adrv904x_cduc_coefs_5g_fs_491520_ibw_400000[] = {
       -60,     42,    -43,     32,    -10,    -18,     45,    -65,     70,    -58,     34,     -5,    -20,     32,    -26,      3,
        28,    -56,     70,    -63,     36,      3,    -41,     64,    -62,     34,     11,    -57,     88,    -90,     61,     -8,
       -51,     94,   -105,     76,    -16,    -56,    113,   -133,    106,    -38,    -49,    124,   -158,    135,    -60,    -44,
       139,   -191,    175,    -93,    -30,    151,   -226,    222,   -135,    -11,    164,   -270,    283,   -192,     20,    175,
      -323,    363,   -270,     65,    185,   -393,    475,   -386,    138,    193,   -495,    648,   -574,    265,    199,   -671,
       971,   -949,    539,    204,  -1095,   1848,  -2125,   1578,    206,  -4251,  19902
};

static const int16_t adrv904x_cduc_coefs_5g_fs_61440_ibw_30000[] = {
       -85,    161,    -61,    -31,     45,     36,    -24,    -32,     22,     38,    -14,    -40,     10,     44,     -5,    -48,
        -1,     51,      7,    -54,    -14,     57,     22,    -58,    -31,     59,     40,    -59,    -50,     57,     60,    -54,
       -71,     50,     82,    -44,    -93,     36,    104,    -26,   -115,     14,    125,     -1,   -133,    -15,    141,     33,
      -147,    -53,    151,     75,   -153,    -99,    153,    124,   -149,   -151,    142,    180,   -131,   -209,    116,    240,
       -96,   -271,     71,    303,    -41,   -335,      4,    366,     41,   -397,    -94,    427,    156,   -456,   -231,    483,
       321,   -508,   -430,    531,    567,   -552,   -746,    570,    991,   -585,  -1357,    596,   1990,   -605,  -3419,    610,
     10411,  15772
};

static const int16_t adrv904x_cduc_coefs_5g_fs_61440_ibw_40000[] = {
        46,   -119,     88,    -61,    -12,     42,    -28,    -17,     38,    -16,    -25,     37,     -7,    -33,     36,      2,
       -40,     34,     13,    -48,     30,     24,    -53,     23,     36,    -58,     13,     49,    -59,      1,     62,    -58,
       -14,     74,    -53,    -31,     85,    -44,    -51,     93,    -30,    -72,     97,    -12,    -93,     97,     11,   -113,
        91,     38,   -131,     78,     69,   -146,     59,    102,   -155,     32,    137,   -158,     -2,    171,   -153,    -44,
       204,   -138,    -93,    232,   -111,   -148,    255,    -72,   -209,    268,    -20,   -272,    270,     49,   -339,    257,
       134,   -405,    225,    239,   -470,    169,    367,   -531,     82,    526,   -587,    -52,    730,   -635,   -259,   1016,
      -674,   -608,   1481,   -703,  -1338,   2525,   -721,  -4108,   9373,  21118
};

static const int16_t adrv904x_cduc_coefs_5g_fs_61440_ibw_50000[] = {
        58,    -30,     24,     -6,    -20,     48,    -71,     80,    -73,     50,    -17,    -15,     36,    -39,     22,      9,
       -43,     66,    -69,     48,     -8,    -36,     69,    -79,     58,    -13,    -41,     85,   -101,     81,    -29,    -38,
        96,   -123,    106,    -47,    -34,    109,   -150,    137,    -72,    -26,    122,   -180,    175,   -104,    -12,    134,
      -215,    222,   -146,      8,    145,   -257,    282,   -202,     39,    155,   -309,    361,   -280,     85,    164,   -378,
       472,   -395,    158,    171,   -479,    644,   -584,    285,    177,   -654,    966,   -958,    558,    181,  -1077,   1842,
     -2133,   1597,    183,  -4232,  19895
};

static const int16_t adrv904x_cduc_coefs_5g_fs_7680_ibw_5000[] = {
       -89,     61,     43,   -171,    177,    -23,   -137,    103,    116,   -258,    101,    219,   -312,     -5,    398,   -349,
      -186,    597,   -294,   -494,    813,    -94,   -975,   1012,    395,  -1802,   1165,   1714,  -4036,   1249,  17398
};

static const int16_t adrv904x_cduc_coefs_high_bw_5g_fs_122880_ibw_60000[] = {
      -103,    179,    -19,    -27,     30,     41,     -6,    -31,      5,     34,      2,    -33,     -7,     34,     11,    -34,
       -16,     33,     21,    -33,    -26,     32,     31,    -30,    -36,     28,     41,    -25,    -46,     21,     50,    -17,
       -55,     12,     59,     -6,    -63,      0,     66,      8,    -69,    -15,     71,     24,    -72,    -33,     72,     42,
       -71,    -52,     69,     62,    -66,    -73,     62,     83,    -56,    -93,     49,    103,    -40,   -113,     30,    122,
       -18,   -130,      5,    138,      9,   -144,    -25,    149,     43,   -152,    -62,    154,     82,   -154,   -103,    151,
       126,   -147,   -149,    139,    173,   -129,   -198,    115,    224,    -98,   -249,     78,    275,    -53,   -301,     24,
       326,     10,   -351,    -50,    376,     96,   -399,   -149,    422,    212,   -443,   -285,    463,    372,   -481,   -478,
       498,    611,   -512,   -784,    525,   1023,   -535,  -1383,    544,   2009,   -550,  -3431,    553,  10415,  15830
};

static const int16_t adrv904x_cduc_coefs_lte_fs_15360_ibw_5000[] = {
        40,    -17,    -26,    -27,    -13,      8,     18,      9,    -14,    -29,    -21,      6,     31,     29,     -1,    -34,
       -40,    -10,     33,     50,     22,    -29,    -59,    -38,     21,     67,     56,     -7,    -71,    -75,    -11,     70,
        95,     35,    -63,   -113,    -64,     49,    127,     96,    -26,   -136,   -132,     -6,    137,    168,     48,   -127,
      -202,    -99,    105,    232,    158,    -68,   -254,   -225,     14,    264,    297,     59,   -259,   -372,   -154,    232,
       448,    275,   -176,   -522,   -427,     83,    591,    621,     67,   -652,   -884,   -309,    702,   1282,    745,   -740,
     -2050,  -1774,    763,   4847,   8621,  10152
};

static const int16_t adrv904x_cduc_coefs_lte_fs_15360_ibw_10000[] = {
        50,    -52,    -36,     59,    -38,    -72,     99,     -5,   -138,    123,     66,   -221,    108,    187,   -303,     27,
       360,   -349,   -150,    573,   -313,   -455,    804,   -124,   -944,   1020,    358,  -1786,   1189,   1682,  -4038,   1282,
     17378
};

static const int16_t adrv904x_cduc_coefs_lte_fs_30720_ibw_5000[] = {
        26,     35,    -11,     11,     -7,     -2,    -10,     -8,     -9,     -5,     -1,      5,      9,     11,     11,      8,
         3,     -3,     -9,    -13,    -14,    -12,     -7,      0,      8,     14,     17,     17,     12,      4,     -5,    -14,
       -20,    -21,    -18,    -10,      1,     12,     21,     25,     24,     17,      5,     -8,    -21,    -28,    -30,    -24,
       -13,      3,     18,     30,     36,     33,     22,      5,    -13,    -30,    -40,    -41,    -33,    -16,      6,     27,
        42,     49,     44,     28,      5,    -20,    -42,    -55,    -55,    -42,    -19,     10,     38,     59,     66,     58,
        36,      4,    -30,    -59,    -74,    -73,    -55,    -22,     17,     54,     80,     88,     75,     44,      1,    -44,
       -81,   -100,    -96,    -70,    -25,     28,     76,    109,    117,     98,     55,     -4,    -64,   -112,   -136,   -128,
       -90,    -28,     44,    108,    150,    158,    129,     68,    -13,    -95,   -158,   -188,   -174,   -118,    -30,     69,
       158,    214,    222,    177,     88,    -29,   -145,   -235,   -273,   -249,   -163,    -32,    116,    247,    328,    337,
       264,    122,    -62,   -247,   -389,   -450,   -407,   -260,    -33,    227,    462,    613,    632,    496,    216,   -165,
      -571,   -910,  -1088,  -1025,   -674,    -34,    849,   1886,   2952,   3912,   4636,   5025
};

static const int16_t adrv904x_cduc_coefs_lte_fs_30720_ibw_10000[] = {
        27,    -34,    -30,    -18,      1,     17,     17,     -1,    -22,    -25,     -6,     22,     32,     14,    -20,    -40,
       -25,     14,     46,     38,     -6,    -49,    -52,     -7,     50,     67,     24,    -45,    -81,    -45,     35,     92,
        70,    -19,    -99,    -96,     -5,    100,    123,     36,    -93,   -149,    -74,     76,    170,    118,    -48,   -186,
      -166,      7,    191,    217,     47,   -183,   -268,   -115,    159,    316,    198,   -115,   -356,   -295,     45,    384,
       407,     55,   -393,   -535,   -196,    377,    684,    394,   -321,   -863,   -685,    199,   1105,   1162,     60,  -1514,
     -2178,   -770,   2717,   6906,   9748
};

static const int16_t adrv904x_cduc_coefs_lte_fs_30720_ibw_15000[] = {
        58,     -6,    -42,    -11,     46,     17,    -62,    -40,     64,     58,    -73,    -92,     66,    121,    -60,   -164,
        35,    201,     -5,   -245,    -47,    280,    109,   -314,   -197,    332,    300,   -339,   -431,    318,    584,   -269,
      -776,    171,   1008,     -7,  -1320,   -279,   1777,    815,  -2643,  -2180,   5541,  14045
};

static const int16_t adrv904x_cduc_coefs_lte_fs_30720_ibw_20000[] = {
        50,    -52,    -36,     59,    -38,    -72,     99,     -5,   -138,    123,     66,   -221,    108,    187,   -303,     27,
       360,   -349,   -150,    573,   -313,   -455,    804,   -124,   -944,   1020,    358,  -1786,   1189,   1682,  -4038,   1282,
     17378
};

static const int16_t adrv904x_cduc_coefs_lte_fs_7680_ibw_5000[] = {
        50,    -52,    -36,     59,    -38,    -72,     99,     -5,   -138,    123,     66,   -221,    108,    187,   -303,     27,
       360,   -349,   -150,    573,   -313,   -455,    804,   -124,   -944,   1020,    358,  -1786,   1189,   1682,  -4038,   1282,
     17378
};

static const int16_t adrv904x_cduc_coefs_lte_iot_fs_15360_ibw_10000[] = {
       -38,     23,     15,     -3,     14,     13,     -9,      9,     14,    -13,      4,     17,    -15,     -1,     20,    -15,
        -6,     24,    -14,    -12,     27,    -11,    -19,     30,     -7,    -26,     31,     -1,    -33,     31,      7,    -40,
        29,     17,    -47,     24,     28,    -52,     17,     40,    -55,      7,     52,    -55,     -6,     64,    -52,    -21,
        75,    -46,    -38,     84,    -35,    -57,     90,    -21,    -77,     92,     -1,    -97,     90,     22,   -115,     82,
        49,   -131,     67,     79,   -144,     46,    111,   -150,     18,    144,   -150,    -17,    176,   -142,    -59,    206,
      -125,   -107,    231,    -96,   -160,    250,    -56,   -219,    260,     -2,   -280,    259,     66,   -343,    243,    151,
      -406,    209,    254,   -467,    151,    380,   -524,     62,    536,   -576,    -71,    737,   -621,   -278,   1019,   -658,
      -626,   1480,   -685,  -1353,   2520,   -701,  -4121,   9364,  21138
};

static const int16_t adrv904x_cduc_coefs_lte_iot_fs_30720_ibw_20000[] = {
        34,    -35,    -19,     10,    -18,    -16,     22,    -11,    -22,     29,     -5,    -31,     32,      5,    -41,     32,
        17,    -52,     29,     33,    -62,     20,     51,    -69,      6,     72,    -72,    -15,     94,    -68,    -42,    114,
       -57,    -74,    130,    -36,   -111,    140,     -4,   -151,    141,     39,   -191,    130,     93,   -227,    103,    157,
      -257,     59,    231,   -275,     -7,    311,   -275,    -97,    396,   -253,   -214,    481,   -200,   -364,    564,   -104,
      -556,    640,     55,   -814,    706,    321,  -1191,    758,    814,  -1873,    795,   2075,  -3943,    814,  17643
};

static const int16_t adrv904x_cduc_coefs_high_bw_5g_fs_122880_ibw_100000[] = {
       -86,     35,    -29,     13,      9,    -33,     52,    -62,     59,    -44,     23,     -2,    -12,     16,     -7,    -10,
        29,    -43,     46,    -36,     16,      9,    -28,     37,    -30,     10,     16,    -40,     52,    -47,     26,      4,
       -34,     52,    -51,     32,      1,    -36,     60,    -64,     46,    -11,    -30,     62,    -73,     58,    -21,    -25,
        65,    -84,     74,    -37,    -15,     64,    -93,     89,    -53,     -4,     62,   -102,    106,    -73,     12,     57,
      -109,    124,    -96,     31,     48,   -114,    142,   -121,     55,     34,   -116,    161,   -150,     84,     15,   -115,
       179,   -182,    120,    -10,   -110,    197,   -218,    162,    -44,    -98,    214,   -259,    214,    -88,    -79,    229,
      -307,    279,   -147,    -49,    243,   -365,    363,   -228,     -3,    256,   -439,    480,   -347,     70,    266,   -545,
       658,   -539,    198,    274,   -725,    985,   -918,    474,    279,  -1152,   1867,  -2098,   1515,    282,  -4311,  19925
};

static adi_adrv904x_ErrAction_e cddc_assign_coefs(  adi_adrv904x_Device_t* const                        device,
                                                    const adi_adrv904x_CarrierFilterApplicationType_e   carrierChannelFilterApplicationSel, 
                                                    const adi_adrv904x_CarrierCfg_t* const              carrierCfg,
                                                    const int16_t** const                               coeffTable,
                                                    int16_t* const                                      coeffTableSize,
                                                    uint32_t* const                                     numberOfFilterTaps,
                                                    uint8_t* const                                      assymetricFilterTaps);

static adi_adrv904x_ErrAction_e cduc_assign_coefs(  adi_adrv904x_Device_t* const                        device,
                                                    const adi_adrv904x_CarrierFilterApplicationType_e   carrierChannelFilterApplicationSel,
                                                    const adi_adrv904x_CarrierCfg_t* const              carrierCfg,
                                                    const int16_t** const                               coeffTable,
                                                    int16_t* const                                      coeffTableSize,
                                                    uint32_t* const                                     numberOfFilterTaps,
                                                    uint8_t* const                                      assymetricFilterTaps);

static uint32_t adrv904x_SampleRateJesdIqRatioCalculate(const uint32_t sampleRate_kHz)
{
    uint32_t samplingRatio = 1U; /* This is default for most cases */
    uint32_t interpolationRatio = 0U;

    if (sampleRate_kHz != 0U)
    {
        samplingRatio = sampleRate_kHz < ADRV904X_JESD_IQ_RATE_KHZ ?
                            ADRV904X_JESD_IQ_RATE_KHZ / sampleRate_kHz : 1U;

        /* Convert to log */
        while (samplingRatio > 1U)
        {
            interpolationRatio++;
            samplingRatio >>= 1U;
        }
    }

    return interpolationRatio;
}

static uint32_t adrv904x_CarrierBandSampleRateRatioCalculate(const uint32_t bandSampleRate_kHz, const uint32_t carrierSampleRate_kHz)
{
    uint32_t samplingRatio = 0U; /* This is default for most cases */
    uint32_t decimationRatio = 0U;

    if (carrierSampleRate_kHz == 0U)
    {
        return decimationRatio;
    }

    samplingRatio = bandSampleRate_kHz;
    samplingRatio /= carrierSampleRate_kHz;
    samplingRatio >>= 1U;
    
    while (samplingRatio > 0U)
    {
        decimationRatio++;
        samplingRatio >>= 1U;
    }
    
    return decimationRatio;
}

static uint32_t adrv904x_CarrierRateCalculate(const uint32_t hsDigRate_kHz, const uint32_t carrierSampleRate_kHz)
{
    uint32_t clkRatio = 0U;
    uint32_t carrierRateRatio = 0U;

    if (carrierSampleRate_kHz == 0U)
    {
        return carrierRateRatio;
    }

    clkRatio = hsDigRate_kHz / carrierSampleRate_kHz;
    carrierRateRatio = 0U;
    while (clkRatio > 1U)
    {
        carrierRateRatio++;
        clkRatio >>= 1U;
    }

    return carrierRateRatio;
}

static void swap(uint16_t* const a, uint16_t* const b)
{
    uint16_t tmp = *a;

    *a = *b;
    *b = tmp;
}

static adi_adrv904x_ErrAction_e adrv904x_CarrierJesdSlotTableCalculate( adi_adrv904x_Device_t* const                            device,
                                                                        const adi_adrv904x_CarrierRadioCfg_t* const   carrierConfigs,
                                                                        adrv904x_CarrierDynamicReconfigProfileCfg_t* const     carrierConfigsOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint16_t indexMap[ADI_ADRV904X_MAX_CARRIERS];
    uint16_t ratios[ADI_ADRV904X_MAX_CARRIERS];
    uint16_t count[ADI_ADRV904X_MAX_CARRIERS];
    uint32_t carrierIdx = 0U;
    uint32_t altCarrierIdx = 0U;
    uint32_t i = 0U;
    uint8_t valid = 0U;
    uint8_t assigned = 0U;
    uint64_t mask = 1U;
    uint32_t minIdx = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigs);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsOut);

    ADI_LIBRARY_MEMSET(indexMap, 0, sizeof(indexMap));
    ADI_LIBRARY_MEMSET(ratios, 0, sizeof(ratios));
    ADI_LIBRARY_MEMSET(count, 0, sizeof(count));

    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        indexMap[carrierIdx] = carrierIdx; /* Index map */
        
        if (carrierConfigs->carriers[carrierIdx].sampleRate_kHz != 0U)
        {
            ratios[carrierIdx] = carrierConfigsOut->internalJesdCfg.frequencyKhz / carrierConfigs->carriers[carrierIdx].sampleRate_kHz;
            count[carrierIdx] = 0U;
        }
        else
        {
            ratios[carrierIdx] = ADRV904X_UNUSED;
            count[carrierIdx] = ADRV904X_UNUSED;
        }
    }

    for (carrierIdx = 0U; carrierIdx < (ADI_ADRV904X_MAX_CARRIERS - 1U); carrierIdx++)
    {
        minIdx = carrierIdx;
        for (altCarrierIdx = carrierIdx + 1U; altCarrierIdx < ADI_ADRV904X_MAX_CARRIERS; altCarrierIdx++)
        {
            if (ratios[altCarrierIdx] < ratios[minIdx])
            {
                minIdx = altCarrierIdx;
            }
        }

        /* Swap */
        swap(&ratios[minIdx], &ratios[carrierIdx]);
        swap(&count[minIdx], &count[carrierIdx]);
        swap(&indexMap[minIdx], &indexMap[carrierIdx]);
    }

    for (i = 0U; i < carrierConfigsOut->internalJesdCfg.numSlots; i++)
    {
        valid = ADI_FALSE;
        assigned = ADI_FALSE;

        for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
        {
            if (count[carrierIdx] == 0U)
            {
                if (assigned == ADI_FALSE)
                {
                    carrierConfigsOut->jesdCfg.slotTable[i] = indexMap[carrierIdx];
                    count[carrierIdx] = (count[carrierIdx] + 1U) % ratios[carrierIdx];                  /* increment the count for the carrier */
                    valid = (carrierConfigs->carriers[indexMap[carrierIdx]].enable > 0U);
                    assigned = ADI_TRUE;
                }
            }
            else
            {
                count[carrierIdx] = (count[carrierIdx] + 1U) % ratios[carrierIdx]; /* increment the count for the carrier */
            }
        }

        if (valid == ADI_TRUE)
        {
            carrierConfigsOut->internalJesdCfg.slotValid |= mask; /* set valid bit associated with this slot. */
        }

        mask <<= 1U;
    }

    carrierConfigsOut->jesdCfg.slotValidLower    = carrierConfigsOut->internalJesdCfg.slotValid;
    carrierConfigsOut->jesdCfg.slotValidUpper    = carrierConfigsOut->internalJesdCfg.slotValid >> 32U;
    carrierConfigsOut->jesdCfg.maxSlot           = carrierConfigsOut->internalJesdCfg.ifaceMaxSlot;

    /*interface slot table */
    ADI_LIBRARY_MEMSET(indexMap, 0, sizeof(indexMap));
    ADI_LIBRARY_MEMSET(ratios, 0, sizeof(ratios));
    ADI_LIBRARY_MEMSET(count, 0, sizeof(count));
    
    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        indexMap[carrierIdx] = carrierIdx; /* Index map */
        if (carrierConfigs->carriers[indexMap[carrierIdx]].sampleRate_kHz != 0U)
        {
            ratios[carrierIdx] = carrierConfigsOut->internalJesdCfg.frequencyKhz / carrierConfigs->carriers[indexMap[carrierIdx]].sampleRate_kHz;
                count[carrierIdx] = 0U;
            }
        else
        {
            ratios[carrierIdx] = ADRV904X_UNUSED;
            count[carrierIdx] = ADRV904X_UNUSED;
        }
    }

    for (carrierIdx = 0U; carrierIdx < (ADI_ADRV904X_MAX_CARRIERS - 1U); carrierIdx++)
    {
        minIdx = carrierIdx;
        for (altCarrierIdx = carrierIdx + 1U; altCarrierIdx < ADI_ADRV904X_MAX_CARRIERS; altCarrierIdx++)
        {
            if (ratios[altCarrierIdx] < ratios[minIdx])
            {
                minIdx = altCarrierIdx;
            }
        }

        /* Swap */
        swap(&ratios[minIdx], &ratios[carrierIdx]);
        swap(&count[minIdx], &count[carrierIdx]);
        swap(&indexMap[minIdx], &indexMap[carrierIdx]);
    }
    
    /* Calculate f_jesd/f_jesd_sample_rate ratio for each carrier after reordering based on sample rate */
    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
            if (carrierConfigs->carriers[indexMap[carrierIdx]].sampleRate_kHz != 0U)
            {
                ratios[carrierIdx] = carrierConfigsOut->internalJesdCfg.frequencyKhz / carrierConfigs->carriers[indexMap[carrierIdx]].sampleRate_kHz;
                count[carrierIdx] = 0U;
            }
        }

    for (i = 0U; i < carrierConfigsOut->internalJesdCfg.ifaceMaxSlot; i++)
    {
        /* Reinitialize before start of new slot table calculation */
        assigned = ADI_FALSE;

        for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
        {
            if (count[carrierIdx] == 0U)
            {
                if (assigned == ADI_FALSE)
                {
                    carrierConfigsOut->internalJesdCfg.ifaceSlotTable[i] = indexMap[carrierIdx];
                    count[carrierIdx] = (count[carrierIdx] + 1U) % ratios[carrierIdx]; /* increment the count for the carrier */
                    assigned = ADI_TRUE;
                }
            }
            else
            {
                count[carrierIdx] = (count[carrierIdx] + 1U) % ratios[carrierIdx]; /* increment the count for the carrier */
            }
        }

        mask <<= 1U; /* Shift mask bit. */
    }

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_CalculateRxSampleXbarSlotConfig(   adi_adrv904x_Device_t* const                            device,
                                                                            const adi_adrv904x_CarrierJesdCfg_t* const   jesdCfg,
                                                                            adrv904x_CarrierDynamicReconfigInternalCfg_t* const     carrierConfigsOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t slotMapped[ADRV904X_NO_OF_JESD_CARRIER_SLOTS];
    uint16_t carrierIdx = 0U;
    uint16_t sampleIdx = 0U;
    uint32_t mask = 0U;
    uint16_t iqFlag = 0U;
    uint32_t m = 0U;
    uint32_t linkIdx = 0U;
    uint16_t slotIdx = 0U;
    JesdComponentCarrierXbarOutput_t tempSlot[ADI_ADRV904X_MAX_CARRIER_SLOTS];
    uint32_t i = 0U;
    uint16_t tmp = 0U;
    uint16_t subFrame = 0U;
    uint16_t subFrameDepth = 0U;
    uint16_t lane = 0U;
    uint16_t laneDepth = 0U;
    uint16_t jesdL = 0U;
    uint16_t profIdx = 0U;
    uint16_t mReal = 0U;

    ADI_LIBRARY_MEMSET(&tempSlot, 0, sizeof(tempSlot));

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, jesdCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsOut);

    ADI_LIBRARY_MEMSET(&slotMapped, 0, sizeof(slotMapped));

    for (linkIdx = 0U; linkIdx < ADI_ADRV904X_MAX_CARRIER_LINKS; linkIdx++)
    { 
        mReal = device->initExtract.jesdSetting.framerSetting[linkIdx].jesdM * ADRV904X_JESD_INT_INTERLEAVING_RATIO;
        for (m = 0U; m < ADI_ADRV904X_MAX_CARRIER_SLOTS; m++)
        {
            carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[m].carrierSelect = jesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].carrierSelect;
            carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[m].carrierXbarSelect.chanSelect = jesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].channelSelect;
            
            /* break loop iteration if converter index is unused. */
            if (jesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].carrierSelect == ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR)
            {
                break;
            }

            profIdx = device->initExtract.chanAssign[jesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].channelSelect];
            if (profIdx == 255U)
            {				
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT( &device->common,
                    recoveryAction,
                    linkIdx,
                    "Framer sample XBAR mapped to an unconfigured CDDC.");
                return recoveryAction;
            }

            carrierIdx = jesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].carrierSelect >> 1U;
            iqFlag = jesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].carrierSelect % 2U;
            sampleIdx = 0U;

            /* Should we check for unused channels for error checking ? */

            if (carrierIdx < ADI_ADRV904X_MAX_CARRIERS)
            {
                mask = 1U << ((jesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].channelSelect << 1U) + iqFlag);

                for (slotIdx = 0U; slotIdx < carrierConfigsOut->profileCfgs[profIdx].internalJesdCfg.ifaceMaxSlot; slotIdx++)
                {
                    if (carrierConfigsOut->profileCfgs[profIdx].internalJesdCfg.ifaceSlotTable[slotIdx] == carrierIdx)
                    {
                        if ((sampleIdx                      == jesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].sampleSelect) &&
                            ((mask & slotMapped[slotIdx])   == 0U))
                        {
                            carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[m].carrierXbarSelect.slotSelect = (adi_adrv904x_JesdComponentCarrierXbar_e)((slotIdx << 1U) + iqFlag);
                            slotMapped[slotIdx] |= mask;
                            break;
                        }
                        else
                        {
                            sampleIdx++;
                        }
                    }
                }

                if (carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[m].carrierXbarSelect.slotSelect == ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR)
                {
                    recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                    ADI_PARAM_ERROR_REPORT( &device->common,
                                            recoveryAction,
                                            carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[m].carrierXbarSelect.slotSelect,
                                            "Incomplete input carrier crossbar. Must assign all valid slots.");
                    return recoveryAction;
                }

                recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
            }
        }

        if ((device->initExtract.framerInterleaveMode[linkIdx]              ==  ADI_TRUE) && 
            (device->initExtract.jesdSetting.framerSetting[linkIdx].jesdM   >   0U))
        {
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

            ADI_LIBRARY_MEMCPY(tempSlot, carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg, mReal * sizeof(JesdComponentCarrierXbarOutput_t));
            
            jesdL = 0U;
            for (i = 0U; i < ADI_ADRV904X_MAX_SERIALIZER_LANES; i++)
            {
                if (((device->initExtract.jesdSetting.framerSetting[linkIdx].serialLaneEnabled >> i) & 0x1U) > 0U)
                {
                    jesdL++;
                }
            }

            if (jesdL == 0U)
            {
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, jesdL, "Invalid Configuration Parameter");
                return recoveryAction;
            }

            subFrameDepth = device->initExtract.jesdSetting.framerSetting[linkIdx].jesdM / jesdL;
            laneDepth = subFrameDepth * ADRV904X_JESD_INT_INTERLEAVING_RATIO;

            if ((subFrameDepth == 0U) || (laneDepth == 0U))
            {
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, subFrameDepth, "Invalid subFrameDepth or laneDepth Parameters");
                return recoveryAction;
            }

            for (i = 0U; i < mReal; i++)
            {
                /* calculate actual virtual converter index output in this slot */
                tmp = (i % subFrameDepth);                                          /* calculate location in subframe row */
                subFrame = ((i % laneDepth) / subFrameDepth);                       /* perform intermediate scaling required for current lane and subframe calculations. */
                lane = (i / laneDepth);                                             /* calculate current lane of the subframe output */
                tmp += (lane * subFrameDepth);
                tmp *= ADRV904X_JESD_INT_INTERLEAVING_RATIO;
                tmp += subFrame;

                /* Assign the sample XBAR values for the actual output sample to this index */
                carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[tmp].carrierXbarSelect.chanSelect    = tempSlot[i].carrierXbarSelect.chanSelect;
                carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[tmp].carrierSelect                   = tempSlot[i].carrierSelect;
                carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[tmp].carrierXbarSelect.slotSelect    = tempSlot[i].carrierXbarSelect.slotSelect;
            }

            recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
        }
    }

    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_CalculateTxSampleXbarSlotConfig(   adi_adrv904x_Device_t* const                          device,
                                                                            const adi_adrv904x_CarrierJesdCfg_t* const   jesdCfg,
                                                                            adrv904x_CarrierDynamicReconfigInternalCfg_t* const     carrierConfigsOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t slotMapped[ADRV904X_NO_OF_JESD_CARRIER_SLOTS];
    uint16_t carrierIdx = 0U;
    uint16_t sampleIdx = 0U;
    uint32_t mask = 0U;
    uint16_t iq = 0U;
    uint16_t slotIdx = 0U;
    uint32_t m = 0U;
    uint32_t linkIdx = 0U;
    JesdComponentCarrierXbarOutput_t tempSlot[ADI_ADRV904X_MAX_CARRIER_SLOTS];
    uint32_t i = 0U;
    uint32_t j = 0U;
    uint16_t tmp = 0U;
    uint16_t subFrame = 0U;
    uint16_t subFrameDepth = 0U;
    uint16_t lane = 0U;
    uint16_t jesdL = 0U;
    uint16_t ipOrdering[ADI_ADRV904X_MAX_CARRIER_SLOTS];
    uint16_t xbarOrdering[ADI_ADRV904X_MAX_CARRIER_SLOTS];
    uint16_t numRows = 0U;
    uint16_t numColumns = 0U;
    uint16_t convIdx = 0U;
    uint16_t index = 0U;
    uint16_t profIdx = 0U;
    uint8_t jesdM = 0U;
    uint16_t mReal = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, jesdCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsOut);

    ADI_LIBRARY_MEMSET(&slotMapped, 0, sizeof(slotMapped));

    ADI_LIBRARY_MEMSET(&tempSlot, 0, sizeof(tempSlot));
    ADI_LIBRARY_MEMSET(&ipOrdering, 0, sizeof(ipOrdering));
    ADI_LIBRARY_MEMSET(&xbarOrdering, 0xFF, sizeof(xbarOrdering));

    for (linkIdx = 0U; linkIdx < ADI_ADRV904X_MAX_CARRIER_LINKS; linkIdx++)
    {
        jesdM = device->initExtract.jesdSetting.deframerSetting[linkIdx].jesdM;
        mReal = jesdM * ADRV904X_JESD_INT_INTERLEAVING_RATIO;
        convIdx = 0U;
        
        for (m = 0U; m < ADI_ADRV904X_MAX_CARRIER_SLOTS; m++)
        {
            carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[m].carrierSelect = jesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].carrierSelect;
            carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[m].carrierXbarSelect.chanSelect = jesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].channelSelect;
            
            /* break loop iteration if converter index is unused. */
            if (jesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].carrierSelect == ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR)
            {
                break;
            }

            profIdx = device->initExtract.chanAssign[jesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].channelSelect];
            if (profIdx == 255U)
            {				
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT( &device->common,
                    recoveryAction,
                    linkIdx,
                    "Deframer sample XBAR mapped to an unconfigured CDDC.");
                return recoveryAction;
            }

            carrierIdx = jesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].carrierSelect >> 1U;
            iq = jesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].carrierSelect % 2U;
            sampleIdx = 0U;

            /* Should we check for unused channels for error checking ? */

            if (carrierIdx < ADI_ADRV904X_MAX_CARRIERS)
            {
                mask = 1U << ((jesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].channelSelect << 1) + iq);

                for (slotIdx = 0; slotIdx < carrierConfigsOut->profileCfgs[profIdx].internalJesdCfg.ifaceMaxSlot; slotIdx++)
                {
                    if (carrierConfigsOut->profileCfgs[profIdx].internalJesdCfg.ifaceSlotTable[slotIdx] == carrierIdx)
                    {
                        if ((sampleIdx                      == jesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].sampleSelect) &&
                            ((mask & slotMapped[slotIdx])   == 0U))
                        {
                            carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[m].carrierXbarSelect.slotSelect = (adi_adrv904x_JesdComponentCarrierXbar_e)((slotIdx << 1U) + iq);
                            slotMapped[slotIdx] |= mask;
                            break;
                        }
                        else
                        {
                            sampleIdx++;
                        }
                    }
                }

                if (carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[m].carrierXbarSelect.slotSelect == ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR)
                {
                    recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, "Incomplete input carrier crossbar. Must assign all valid slots.");
                    return recoveryAction;
                }

                recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
            }
        }

        if ((device->initExtract.deframerInterleaveMode[linkIdx]            ==  ADI_TRUE) &&
            (device->initExtract.jesdSetting.deframerSetting[linkIdx].jesdM >   0U))
        {
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

            if ((mReal * sizeof(JesdComponentCarrierXbarOutput_t)) > sizeof(tempSlot))
            {
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, mReal, "Invalid Configuration Parameter");
                return recoveryAction;
            }

            ADI_LIBRARY_MEMCPY(tempSlot, carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg, mReal * sizeof(JesdComponentCarrierXbarOutput_t));
            
            jesdL = 0U;
            for (i = 0U; i < ADI_ADRV904X_MAX_DESERIALIZER_LANES; i++)
            {
                if (((device->initExtract.jesdSetting.deframerSetting[linkIdx].deserialLaneEnabled >> i) & 0x1U) > 0U)
                {
                    jesdL++;
                }
            }
            
            if (jesdL == 0U)
            {
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, jesdL, "Invalid Configuration Parameter");
                return recoveryAction;
            }

            subFrameDepth = jesdM / jesdL;

            if (subFrameDepth == 0U)
            {
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, subFrameDepth, "Invalid Configuration Parameter");
                return recoveryAction;
            }
            
            for (i = 0U; i < mReal; i++)
            {
                /* calculate actual virtual converter index output in this slot */
                tmp = (i % subFrameDepth);                                          /* calculate location in subframe row */
                subFrame = (i / subFrameDepth);                                     /* perform intermediate scaling required for current lane and subframe calculations. */
                lane = (subFrame % jesdL);                                          /* calculate current lane of the subframe output */
                subFrame /= jesdL;                                                  /* final calculation to determine which subframe is active */
                tmp += ((lane * mReal) / jesdL);
                tmp += (subFrame * subFrameDepth);
                ipOrdering[i] = tmp;
            }

            numColumns = ADRV904X_JESD_XBAR_NUM_COLUMNS;
            numRows = mReal / numColumns;
            numRows += ((mReal % numColumns) > 0U) ? 1U : 0U;

            for (subFrame = 0U; subFrame < ADRV904X_JESD_INT_INTERLEAVING_RATIO; subFrame++)
            {
                index = 0U;

                for (j = 0U; j < numRows; j++)
                {
                    for (i = 0U; i < ADRV904X_JESD_INT_INTERLEAVING_RATIO; i++)
                    {
                        tmp = (j * numColumns) + (subFrame * 4U) + i;

                        if (index < jesdM)
                        {
                            xbarOrdering[tmp] = ipOrdering[convIdx];
                            carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[tmp].carrierXbarSelect.chanSelect    = tempSlot[ipOrdering[convIdx]].carrierXbarSelect.chanSelect;
                            carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[tmp].carrierSelect                   = tempSlot[ipOrdering[convIdx]].carrierSelect;
                            carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[tmp].carrierXbarSelect.slotSelect    = tempSlot[ipOrdering[convIdx]].carrierXbarSelect.slotSelect;
                            convIdx++;
                        }
                        else
                        {
                            carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[tmp].carrierXbarSelect.chanSelect    = 0U;
                            carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[tmp].carrierSelect                   = ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR;
                            carrierConfigsOut->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[tmp].carrierXbarSelect.slotSelect    = ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR;
                        }
                        index++;
                    }
                }
            }

            recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
        }
    }

    return recoveryAction;
}


/**
* \brief Final delay calculation. Accumulates all internal delay calculations and combines into the device delay configurations written to part
*
* \dep_begin
* \dep{device->common.devHalInfo}
* \dep_end
*
* \pre adrv904x_CducDelayCalculate
* \pre adrv904x_CddcDelayCalculate
*
* \param[in] device Pointer to the ADRV904X device data structure
* \param[in,out] carrierConfigs holds the user selected values for reconfiguration
* \param[in,out] carrierConfigsOut holds the calculated values during reconfiguration
* \param[in, out] carrierDelayParams delay configuration written to part
*
* \retval adi_adrv904x_ErrAction_e - ADI_ADRV904X_ERR_ACT_NONE if Successful
*/
static adi_adrv904x_ErrAction_e adrv904x_CalculateDelayParameters(  adi_adrv904x_Device_t* const device, 
                                                                    const adi_adrv904x_CarrierRadioCfg_t* const carrierConfigs,
                                                                    adrv904x_CarrierDynamicReconfigProfileCfg_t* const carrierConfigsOut,
                                                                    adrv904x_CarrierDelayParameters_t* const carrierDelayParams)
{
        
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t carrierIdx = 0U;
    uint32_t groupDelayOffset[ADI_ADRV904X_MAX_CARRIERS];
    uint32_t groupDelay[ADI_ADRV904X_MAX_CARRIERS];
    uint32_t maxDelay = 0U;
    int32_t tmpDelay = 0U;
    uint32_t daisyEnableMask = 0U;
    uint32_t delayIdx = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigs);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsOut);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierDelayParams);

    ADI_LIBRARY_MEMSET(&groupDelayOffset, 0, sizeof(groupDelayOffset));
    ADI_LIBRARY_MEMSET(&groupDelay, 0, sizeof(groupDelay));
    
    if (carrierDelayParams->jesdIfaceFrequencyKhz == 0U)
    {               
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierDelayParams->jesdIfaceFrequencyKhz, "jesdIfaceFrequency is 0.");
        return recoveryAction;
    }
    
    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        groupDelay[carrierIdx] = carrierDelayParams->carrierDelay[carrierIdx];
        maxDelay = groupDelay[carrierIdx] > maxDelay ? groupDelay[carrierIdx] : maxDelay;   
        
        /* Clear array */
        groupDelayOffset[carrierIdx] = 0U;
    }

    /* convert the group delays to group delay excess in units of their sample rate*/
    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        if (carrierConfigs->carriers[carrierIdx].enable == 1U)
        {
            /* conversion to excess delay */
            tmpDelay = maxDelay - groupDelay[carrierIdx];
            /* scale by 2 for rounding purposes */
            tmpDelay <<= 1U;
            /* conversion to units of the carrier's own sample rate */
            tmpDelay = tmpDelay * carrierConfigs->carriers[carrierIdx].sampleRate_kHz;
            /* scale to jesd interface sample rate             */
            tmpDelay >>= carrierDelayParams->ratioLog2;
            tmpDelay /= carrierDelayParams->jesdIfaceFrequencyKhz;
            /* complete the rounding operation */
            tmpDelay += 1U;
            tmpDelay >>= 1U;
            /* place converted value back in vector */
            groupDelayOffset[carrierIdx] = tmpDelay;
            /* Check converted value against limits */
            if (tmpDelay > ADRV904X_MAX_CARRIER_DELAY_VALUE)
            {                
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, groupDelayOffset[carrierIdx], "Carrier group delay correction of %d samples exceeds limits.");
                return recoveryAction;
            }
        }
    }

    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        tmpDelay = groupDelayOffset[carrierIdx];
        daisyEnableMask = 0U;
        carrierDelayParams->delayValue[delayIdx] = tmpDelay;
        while (tmpDelay > 0)
        {
            /* Moving check to start of the loop (from after dly_idx++;) per TRDIG-3467. */
            /*   Change is to check the current delay element index, not the incremented delay element index. */
            /*   Check must be performed prior to prms->carrier_select[dly_idx] = cc; for array indexing protection. */
            /* Error check against number of delays */
            if (delayIdx >= ADRV904X_NO_OF_CARRIER_DELAY_FIFOS)
            {               
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, delayIdx, "Carrier group delay correction requires too many delay elements.");
                return recoveryAction;
            }

            carrierDelayParams->delayCmpEnable |= 1U << carrierIdx;
            carrierDelayParams->memoryEnable |= 1U << delayIdx;
            carrierDelayParams->daisyChainEnable |= daisyEnableMask;
            carrierDelayParams->carrierSelect[delayIdx] = carrierIdx;
            if (tmpDelay > ADRV904X_CARRIER_DELAY_ELEMENT_SIZE)
            {
                tmpDelay -= ADRV904X_CARRIER_DELAY_ELEMENT_SIZE;
                daisyEnableMask = (uint16_t)(1U << (delayIdx + 1U));
            }
            else
            {
                tmpDelay = 0U;
            }
            delayIdx++;
        }
    }

    /*Copy to output struct */
    carrierConfigsOut->delayCfg.delayCmpEnable = carrierDelayParams->delayCmpEnable;
    carrierConfigsOut->delayCfg.delayMemEnable = carrierDelayParams->memoryEnable;
    carrierConfigsOut->delayCfg.daisyChainEnable = carrierDelayParams->daisyChainEnable;
    for (delayIdx = 0U; delayIdx < ADRV904X_NO_OF_CARRIER_DELAY_FIFOS; delayIdx++)
    {
        carrierConfigsOut->delayCfg.delayCarrierSelect[delayIdx] = carrierDelayParams->carrierSelect[delayIdx];
        carrierConfigsOut->delayCfg.delayValue[delayIdx] = carrierDelayParams->delayValue[delayIdx];
    }

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
    return recoveryAction;
}

/**
* \brief Calculates resource share delay
*
* \dep_begin
* \dep{device->common.devHalInfo}
* \dep_end
*
* \param[in] device Pointer to the ADRV904X device data structure
* \param[in] carrierMask carrier mask
* \param[in] resourcePipe holds the calculated resource share configuration
* \param[in] jesdClkPeriod_ns jesd clk period in nanoseconds
* \param[in] carrierNum the carrier to calculated for
*
* \retval delay Resource Share delay for the requested carrier
*/
static uint32_t adrv904x_ResourceShareDelay(    adi_adrv904x_Device_t* const device, 
                                                uint32_t carrierMask, 
                                                const adrv904x_ResourceShareDelayParams_t* const resourcePipe, 
                                                const uint32_t jesdClkPeriod_ns,
                                                const uint32_t carrierNum)
{
        
    uint32_t carrierArrivalSlot[ADI_ADRV904X_MAX_CARRIERS];
    uint32_t carrierSlotAllocation[ADRV904X_NO_OF_JESD_CARRIER_SLOTS];
    uint32_t carrierSlotIn[ADRV904X_NO_OF_JESD_CARRIER_SLOTS][ADI_ADRV904X_MAX_CARRIERS];
    uint32_t carrierSlotOut[ADRV904X_NO_OF_JESD_CARRIER_SLOTS];
    uint32_t carrierFirstInSlot[ADI_ADRV904X_MAX_CARRIERS];
    int32_t carrierFirstOutSlot[ADI_ADRV904X_MAX_CARRIERS];
    int32_t carrierDelay[ADI_ADRV904X_MAX_CARRIERS];
    int32_t maxCarrierPeriod = 0;
    int32_t maxSlots = 0;
    int32_t slotStepSize = 0;
    int32_t firstEnabledCarrier = 1;
    int32_t firstCarrierNum = 0;
    int32_t minCarrierDelay = 0;
    int32_t i = 0;
    int32_t j = 0;
    uint32_t carrierIdx = 0;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, resourcePipe);
    
    ADI_LIBRARY_MEMSET(&carrierArrivalSlot, 0, sizeof(carrierArrivalSlot));
    ADI_LIBRARY_MEMSET(&carrierSlotAllocation, 0, sizeof(carrierSlotAllocation));
    ADI_LIBRARY_MEMSET(&carrierSlotIn, 0, sizeof(carrierSlotIn));
    ADI_LIBRARY_MEMSET(&carrierSlotOut, 0, sizeof(carrierSlotOut));
    ADI_LIBRARY_MEMSET(&carrierFirstInSlot, 0, sizeof(carrierFirstInSlot));
    ADI_LIBRARY_MEMSET(&carrierFirstOutSlot, 0, sizeof(carrierFirstOutSlot));
    ADI_LIBRARY_MEMSET(&carrierDelay, 0, sizeof(carrierDelay));

    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {        
        maxCarrierPeriod = (maxCarrierPeriod > resourcePipe[carrierIdx].period) ? maxCarrierPeriod : resourcePipe[carrierIdx].period;        
    }

    if (jesdClkPeriod_ns == 0U)
    {
        return 0U;
    }
    
    maxSlots = maxCarrierPeriod / jesdClkPeriod_ns;
    
    for (i = 0; i < maxSlots; i++)
    {
        carrierSlotAllocation[i] = ADI_ADRV904X_MAX_CARRIERS;
    }

    slotStepSize = maxSlots + 1;

    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        if ((carrierMask & (1 << carrierIdx)) > 0)
        {
            if (firstEnabledCarrier == 1)
            {
                minCarrierDelay = resourcePipe[carrierIdx].delay;
                firstEnabledCarrier = 0;
            }
            else
            {
                minCarrierDelay = (minCarrierDelay < resourcePipe[carrierIdx].delay) ? minCarrierDelay : resourcePipe[carrierIdx].delay;
            }
        }
    }

    firstEnabledCarrier = 1U;
    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        if ((minCarrierDelay == resourcePipe[carrierIdx].delay) && (firstEnabledCarrier == 1))
        {
            firstCarrierNum = carrierIdx;
            firstEnabledCarrier = 0;
            break;
        }
    }

    /* Slot table delay */
    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        if ((carrierMask & (1 << carrierIdx)) > 0)
        {
            carrierArrivalSlot[carrierIdx] = ((resourcePipe[carrierIdx].delay - resourcePipe[firstCarrierNum].delay) / jesdClkPeriod_ns) % maxSlots;
            slotStepSize = resourcePipe[carrierIdx].period / jesdClkPeriod_ns;
        }
        else
        {
            carrierArrivalSlot[carrierIdx] = maxSlots;
            slotStepSize = maxSlots + 1;
        }
        /* allocating slots based on priority (lowest carrier highest priority)*/
        j = carrierArrivalSlot[carrierIdx];
        
        if (slotStepSize <= 0)
        {
            return 0;
        }
        
        while (j >= 0) {
            j = j - slotStepSize;
        }

        j = j + slotStepSize;

        while (j < maxSlots)
        {
            if (carrierSlotAllocation[j] == ADI_ADRV904X_MAX_CARRIERS)
            {
                carrierSlotAllocation[j] = carrierIdx;
                j = j + slotStepSize;
            }
            else
            {
                j = j + 1;
            }
        }

        /*  arrival order */
        j = carrierArrivalSlot[carrierIdx];
        while (j >= 0)
        {
            j = j - slotStepSize;
        }

        j = j + slotStepSize;
        carrierFirstInSlot[carrierIdx] = j;

        while (j < maxSlots)
        {
            carrierSlotIn[j][carrierIdx] = 1;
            j = j + slotStepSize;
        }
    }

    /*  Rotating once due to delay difference between data and valids */
    carrierSlotOut[0] = carrierSlotAllocation[maxSlots - 1];
    for (i = 1; i < maxSlots; i++)
    {
        carrierSlotOut[i] = carrierSlotAllocation[i - 1];
    }

    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        carrierFirstOutSlot[carrierIdx] = maxSlots;
        for (j = 0U; j < maxSlots; j++)
        {
            if ((carrierSlotOut[j] == carrierIdx) && (carrierFirstOutSlot[carrierIdx] > j))
            {
                carrierFirstOutSlot[carrierIdx] = j;
            }
        }
    }

    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        carrierDelay[carrierIdx] = (carrierFirstOutSlot[carrierIdx] - carrierFirstInSlot[carrierIdx]) * jesdClkPeriod_ns;
        if (carrierDelay[carrierIdx] < 0)
        {
            carrierDelay[carrierIdx] = carrierDelay[carrierIdx] + maxSlots*jesdClkPeriod_ns;
        }
        while (carrierDelay[carrierIdx] > resourcePipe[carrierIdx].period)
        {
            carrierDelay[carrierIdx] = carrierDelay[carrierIdx] - resourcePipe[carrierIdx].period;
        }
    }

    return carrierDelay[carrierNum];
}

/**
* \brief Calculates channel filter delay
*
* \dep_begin
* \dep{device->common.devHalInfo}
* \dep_end
*
* \param[in] device Pointer to the ADRV904X device data structure
* \param[in] dataPipeStop dataPipeStop
* \param[in] bypassFilter bypassFilter
* \param[in] jesdClkPeriod_ns jesd clk period in nanoseconds
* \param[in] carrierClkPeriod_ns carrier clock period in nanoseconds
*
* \retval delay the calculated channel filter delay
*/
static uint32_t adrv904x_CalculateChannelFilterDelay(   adi_adrv904x_Device_t* const device, 
                                                        const uint8_t dataPipeStop,
                                                        const uint8_t bypassFilter,
                                                        const uint32_t jesdClkPeriod_ns, 
                                                        const uint32_t carrierClkPeriod_ns)
{
        
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);

    
    uint32_t delay;
    uint32_t accumCount;
    uint32_t accumDelay;

    if (bypassFilter == 0U)
    {
        if (dataPipeStop <= 17U)
        {
            accumCount = 8U;
        }
        else if (dataPipeStop <= 47U)
        {
            accumCount = 16U;
        }
        else
        {
            accumCount = 32U;
        }
        accumDelay = accumCount < carrierClkPeriod_ns ? accumCount : carrierClkPeriod_ns;
        delay = accumDelay + (((dataPipeStop - 1U) / 6) * jesdClkPeriod_ns);
    }
    else
    {
        delay = jesdClkPeriod_ns;
    }

    return delay;
}

/**
* \brief Calculates half band filter delay
*
* \dep_begin
* \dep{device->common.devHalInfo}
* \dep_end
*
* \param[in] device Pointer to the ADRV904X device data structure
* \param[in] numberOfHalfBands the number of half bands
* \param[in] carrierClkPeriod_ns carrier clock period in nanoseconds
*
* \retval delay the calculated channel filter delay
*/
static uint32_t adrv904x_CalculateHalfBandFilterDelay( adi_adrv904x_Device_t* const device, 
                                                                        const uint8_t numberOfHalfBands, 
                                                                        const uint32_t carrierClkPeriod_ns)
{
    const int32_t halfBandDelays[ADRV904X_NO_OF_HALF_BAND_DELAYS] = { 35, 9, 7, 5, 5 };
    uint32_t delay = 0U;
    uint32_t i = 0U;
        
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);

    for (i = 0U; (i < numberOfHalfBands) && (i < ADRV904X_NO_OF_HALF_BAND_DELAYS); i++)
    {
        delay += halfBandDelays[i] * (carrierClkPeriod_ns >> (i + 1U));
    }

    return delay;
}

/**
* \brief Performs cduc carrier delay calculations
*
* \dep_begin
* \dep{device->common.devHalInfo}
* \dep_end
*
* \param[in] device Pointer to the ADRV904X device data structure
* \param[in] selectedChannel a channel used to read the carrier registers. Any channel that's enabled in this config will work.
* \param[in] carrierConfigsOut holds the calculated values during reconfiguration
* \param[in, out] carrierDelayParams delay configuration written to part
*
* \retval adi_adrv904x_ErrAction_e - ADI_ADRV904X_ERR_ACT_NONE if Successful
*/
static adi_adrv904x_ErrAction_e adrv904x_CalculateCducCarrierDelay( adi_adrv904x_Device_t* const device,
                                                                    const uint32_t selectedChannel,
                                                                    const adrv904x_CarrierDynamicReconfigProfileCfg_t* const carrierConfigsOut,
                                                                    const adi_adrv904x_ChannelFilterOutputCfg_t* const carrierChannelFilter,
                                                                    adrv904x_CarrierDelayParameters_t* const carrierDelayParams)
{
        
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t carrierIdx = 0U;
    uint8_t carrierSlots[ADI_ADRV904X_MAX_CARRIERS];
    uint8_t numHalfBandFilter[ADI_ADRV904X_MAX_CARRIERS];
    uint8_t carrierClkPeriod_ns[ADI_ADRV904X_MAX_CARRIERS];
    uint8_t jesdClkPeriod_ns;
    adrv904x_InternalDelayParams_t delays[ADI_ADRV904X_MAX_CARRIERS];
    adrv904x_ResourceShareDelayParams_t resourcePipe[ADI_ADRV904X_MAX_CARRIERS];
    uint8_t calculateDelays;
    uint32_t totalDelay[ADI_ADRV904X_MAX_CARRIERS];
    uint8_t dataPipeStop[ADI_ADRV904X_MAX_CARRIERS];
    uint8_t bypassFilter[ADI_ADRV904X_MAX_CARRIERS];
    uint32_t perStageCarrierEnable;
    uint8_t carriersEnabled = 0U;
    uint8_t mask = 1U;
    uint32_t maxCarrierDelay = 0U;
    uint32_t delayDiff = 0U;
    uint32_t bandClkPeriod[ADRV904X_NO_OF_BANDS];
    int32_t bandEnableOffset[ADRV904X_NO_OF_BANDS];
    uint32_t bandAlignDelay[ADI_ADRV904X_MAX_CARRIERS];
    uint32_t channelFilterBaseAddr = (uint32_t)ADRV904X_BF_SLICE_TX_0__TX_CDUC_TX_CHANNEL_FILTER;
    uint32_t channelFilterStride = ADRV904X_BF_SLICE_TX_1__TX_CDUC_TX_CHANNEL_FILTER - ADRV904X_BF_SLICE_TX_0__TX_CDUC_TX_CHANNEL_FILTER;
    uint32_t i = 0U;
    uint32_t hb = 0U;
    jesdClkPeriod_ns = (1 << carrierDelayParams->ratioLog2);

    /* Fixed delays */
    uint32_t hbResourceSharePipeDelay = 2U;
    uint32_t hbTransposePipeDelay = 1U;
    uint32_t hbAdditionalPipeDelay = hbResourceSharePipeDelay + hbTransposePipeDelay;
    uint32_t ncoResourceSharePipeDelay = 2U;
    uint32_t cmulDelay = 8U;
    uint32_t gainMulDelay = jesdClkPeriod_ns;
    uint32_t preBandAlignPipeDelay = 1U;
    uint32_t additionalPipeDelay = cmulDelay + gainMulDelay + preBandAlignPipeDelay;
    uint32_t bandAlignPipeDelay = 1;
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsOut);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierDelayParams);

    ADI_LIBRARY_MEMSET(&delays, 0, sizeof(delays));
    ADI_LIBRARY_MEMSET(&resourcePipe, 0, sizeof(resourcePipe));
    ADI_LIBRARY_MEMSET(&bandEnableOffset, 0, sizeof(bandEnableOffset));
    ADI_LIBRARY_MEMSET(&bandAlignDelay, 0, sizeof(bandAlignDelay));

    bandClkPeriod[0] = (1 << device->initExtract.rx.rxChannelCfg[selectedChannel].bandRatio[0]);
    bandClkPeriod[1] = (1 << device->initExtract.rx.rxChannelCfg[selectedChannel].bandRatio[1]);

    channelFilterBaseAddr += (channelFilterStride * selectedChannel);
    
    carriersEnabled = carrierConfigsOut->carriersEnabled;

    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        resourcePipe[carrierIdx].period = 1U;
        resourcePipe[carrierIdx].delay = 0U;
        totalDelay[carrierIdx] = 0U;

        mask <<= 1U;

        /* Clearing values */
        delays[carrierIdx].delayMatchEnable = 0U;
        delays[carrierIdx].resource = 0U;

        recoveryAction = adrv904x_ChannelFilter_CarrierEndBank_BfGet(device, NULL, (adrv904x_BfChannelFilterChanAddr_e)channelFilterBaseAddr, carrierIdx, &dataPipeStop[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_ChannelFilter_CarrierBypassFilter_BfGet(device, NULL, (adrv904x_BfChannelFilterChanAddr_e)channelFilterBaseAddr, carrierIdx, &bypassFilter[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }
    }

    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {        
        numHalfBandFilter[carrierIdx] = carrierConfigsOut->carrierCfgs.interpolationRatio[carrierIdx];
        carrierSlots[carrierIdx] = 0U;
        carrierClkPeriod_ns[carrierIdx] = (1U << carrierConfigsOut->carrierCfgs.carrierRateRatio[carrierIdx]);
        if ((carriersEnabled & (1 << carrierIdx)) > 0U)
        {
            for (uint8_t s = 0U; s < ADRV904X_MAX_NO_OF_JESD_SLOTS; s++)
            {
                if (carrierDelayParams->slotTable[s] == carrierIdx)
                {
                    carrierSlots[carrierIdx] = s;
                    break;
                }
            }
        }
    }

    /* Calculate channel filter delay */
    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        if ((carriersEnabled & (1 << carrierIdx)) > 0U)
        {
            delays[carrierIdx].channelFilter.pipe = adrv904x_CalculateChannelFilterDelay(device, dataPipeStop[carrierIdx], bypassFilter[carrierIdx], jesdClkPeriod_ns, carrierClkPeriod_ns[carrierIdx]);
            delays[carrierIdx].slotTable = carrierSlots[carrierIdx] * jesdClkPeriod_ns;
        }
    }

    /*  First pass of the loop is to determine which carriers will use delay matching */
    /*  Second pass of the loop is to calculate each carrier delay with the delay matching component included */
    calculateDelays = ADI_FALSE;
    for (i = 0U; i < 2; i++)
    {
        for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
        {
            resourcePipe[carrierIdx].period = carrierClkPeriod_ns[carrierIdx];
            delays[carrierIdx].halfBandFilter.pipe = 0U;
        }

        for (hb = 0; hb < ADRV904X_NO_OF_HALF_BAND_DELAYS; hb++)
        {
            perStageCarrierEnable = 0U;
            for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
            {
                resourcePipe[carrierIdx].delay = delays[carrierIdx].slotTable + delays[carrierIdx].channelFilter.pipe + (uint32_t)delays[carrierIdx].delayMatchEnable + delays[carrierIdx].halfBandFilter.pipe;       

                if (numHalfBandFilter[carrierIdx] > hb)
                {
                    resourcePipe[carrierIdx].period >>= 1U;
                }
                perStageCarrierEnable |= (numHalfBandFilter[carrierIdx] > hb) ? (carriersEnabled & (1U << carrierIdx)) : 0U;
            }
            for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
            {
                if (numHalfBandFilter[carrierIdx] > hb)
                {
                    mask = (hb == 0) ? 0xFFu : (carrierIdx < (ADI_ADRV904X_MAX_CARRIERS >> 1U)) ? 0x0Fu : 0xF0U;
                    delays[carrierIdx].halfBandFilter.pipe += adrv904x_ResourceShareDelay(device, (perStageCarrierEnable & mask), resourcePipe, 1U, carrierIdx) + hbAdditionalPipeDelay;
                }
            }
        }

        /*  Accounting for resource share block used before NCO */
        for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
        {
            resourcePipe[carrierIdx].delay = delays[carrierIdx].slotTable + delays[carrierIdx].channelFilter.pipe + (uint32_t)delays[carrierIdx].delayMatchEnable + delays[carrierIdx].halfBandFilter.pipe;
        }
        for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
        {
            mask = (carrierIdx < (ADI_ADRV904X_MAX_CARRIERS >> 1U)) ? 0x0Fu : 0xF0U;
            delays[carrierIdx].resource = adrv904x_ResourceShareDelay(device, (carriersEnabled & mask), resourcePipe, 1U, carrierIdx) + ncoResourceSharePipeDelay;
        }

        /*  hb filters , channel filter, interleaver delays */
        for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
        {
            if ((carriersEnabled & (1 << carrierIdx)) > 0U)
            {
                if (bypassFilter[carrierIdx] == 0U)
                {
                    delays[carrierIdx].channelFilter.tap = ((carrierChannelFilter->numberOfFilterTaps[carrierIdx] - 1U) * carrierClkPeriod_ns[carrierIdx] >> 1);
                }
                delays[carrierIdx].halfBandFilter.tap = adrv904x_CalculateHalfBandFilterDelay(device, numHalfBandFilter[carrierIdx], carrierClkPeriod_ns[carrierIdx]);

                totalDelay[carrierIdx] = delays[carrierIdx].channelFilter.tap + delays[carrierIdx].channelFilter.pipe + 
                                            delays[carrierIdx].halfBandFilter.tap + delays[carrierIdx].halfBandFilter.pipe +
                                            delays[carrierIdx].delayMatchEnable +
                                            delays[carrierIdx].slotTable +
                                            delays[carrierIdx].resource;

                if (((totalDelay[carrierIdx] + additionalPipeDelay - bandEnableOffset[carrierConfigsOut->carrierCfgs.bandSelect[carrierIdx]]) % bandClkPeriod[carrierConfigsOut->carrierCfgs.bandSelect[carrierIdx]]) == 0)
                {
                    bandAlignDelay[carrierIdx] = 0;
                }
                else
                {
                    bandAlignDelay[carrierIdx] = bandClkPeriod[carrierConfigsOut->carrierCfgs.bandSelect[carrierIdx]] - ((totalDelay[carrierIdx] + additionalPipeDelay - bandEnableOffset[carrierConfigsOut->carrierCfgs.bandSelect[carrierIdx]]) % bandClkPeriod[carrierConfigsOut->carrierCfgs.bandSelect[carrierIdx]]);
                }

                totalDelay[carrierIdx] = totalDelay[carrierIdx] + bandAlignDelay[carrierIdx] + additionalPipeDelay + bandAlignPipeDelay;
                maxCarrierDelay = maxCarrierDelay > totalDelay[carrierIdx] ? maxCarrierDelay : totalDelay[carrierIdx];
                carrierDelayParams->carrierDelay[carrierIdx] = (uint16_t)totalDelay[carrierIdx];
            }
            else
            {
                carrierDelayParams->carrierDelay[carrierIdx] = 0U;
            }
        }

        /*  break on second loop iteration */
        if (calculateDelays == ADI_TRUE)
        {
            break;
        }

        for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
        {
            if ((carriersEnabled & (1 << carrierIdx)) > 0U)
            {
                delayDiff = maxCarrierDelay - totalDelay[carrierIdx];
                /*  Enable delay matching only if the delay offset is explictly greater than 0 .5 UI of the carrier. */
                /*  This is because enabling delay match adds more than the currently calculated delay to the carrier */
                /*  which would push it beyond the 0 .5 UI limit in this case */
                delays[carrierIdx].delayMatchEnable = ((delayDiff << 1U) > carrierClkPeriod_ns[carrierIdx]) ? 1U : 0U;
                /*  Extra delay due to delay match block */
                /* TODO: Put back when delay block is fixed
                 * delays[carrierIdx].delayMatchEnable = delays[carrierIdx].delayMatchEnable * jesdClkPeriod_ns;
                 * */
                delays[carrierIdx].delayMatchEnable = 0U;
            }
        }
        
        calculateDelays = ADI_TRUE;
    }

    return recoveryAction;
}

/**
* \brief Performs cddc carrier delay calculations
*
* \dep_begin
* \dep{device->common.devHalInfo}
* \dep_end
*
* \param[in] device Pointer to the ADRV904X device data structure
* \param[in] selectedChannel The channel used to configure, any channel enabled in this profile will work
* \param[in] carrierConfigsOut holds the calculated values during reconfiguration
* \param[in] carrierChannelFilter holds output settings from FW channel filter calculation
* \param[in, out] carrierDelayParams delay configuration written to part
*
* \retval adi_adrv904x_ErrAction_e - ADI_ADRV904X_ERR_ACT_NONE if Successful
*/
static adi_adrv904x_ErrAction_e adrv904x_CalculateCddcCarrierDelay( adi_adrv904x_Device_t* const device,
                                                                    uint32_t selectedChannel,
                                                                    const adrv904x_CarrierDynamicReconfigProfileCfg_t* const carrierConfigsOut,
                                                                    const adi_adrv904x_ChannelFilterOutputCfg_t* const carrierChannelFilter, 
                                                                    adrv904x_CarrierDelayParameters_t* const carrierDelayParams)
{
        
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t carrierIdx = 0U;
    uint8_t carrierSlots[ADI_ADRV904X_MAX_CARRIERS];
    uint8_t numHalfBandFilter[ADI_ADRV904X_MAX_CARRIERS];
    uint8_t carrierClkPeriod_ns[ADI_ADRV904X_MAX_CARRIERS];
    uint8_t jesdClkPeriod_ns;
    adrv904x_InternalDelayParams_t delays[ADI_ADRV904X_MAX_CARRIERS];
    adrv904x_ResourceShareDelayParams_t resourcePipe[ADI_ADRV904X_MAX_CARRIERS];
    uint32_t totalDelay[ADI_ADRV904X_MAX_CARRIERS];
    uint8_t dataPipeStop[ADI_ADRV904X_MAX_CARRIERS]; 
    uint8_t bypassFilter[ADI_ADRV904X_MAX_CARRIERS];
    uint32_t perStageCarrierEnable;
    uint8_t carriersEnabled = 0U;
    uint8_t mask = 1U;
    uint32_t maxCarrierDelay = 0U;
    uint32_t delayDiff = 0U;
    uint32_t bandClkPeriod[ADRV904X_NO_OF_BANDS];
    uint32_t channelFilterBaseAddr = (uint32_t)ADRV904X_BF_SLICE_RX_0__RX_CDDC_RX_CHANNEL_FILTER;
    uint32_t channelFilterStride = ADRV904X_BF_SLICE_RX_1__RX_CDDC_RX_CHANNEL_FILTER - ADRV904X_BF_SLICE_RX_0__RX_CDDC_RX_CHANNEL_FILTER;
    uint32_t hb = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsOut);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierChannelFilter);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierDelayParams);
   
    bandClkPeriod[0] = (1 << device->initExtract.rx.rxChannelCfg[selectedChannel].bandRatio[0]);
    bandClkPeriod[1] = (1 << device->initExtract.rx.rxChannelCfg[selectedChannel].bandRatio[1]);

    channelFilterBaseAddr += (channelFilterStride * selectedChannel);
    jesdClkPeriod_ns = (1 << carrierDelayParams->ratioLog2);
    carriersEnabled = carrierConfigsOut->carriersEnabled;

    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        resourcePipe[carrierIdx].period = 1U;
        resourcePipe[carrierIdx].delay = 0U;
        totalDelay[carrierIdx] = 0U;

        mask <<= 1U;

        /* Clearing values */
        delays[carrierIdx].delayMatchEnable = 0U;
        delays[carrierIdx].resource = 0U;
        
        recoveryAction = adrv904x_ChannelFilter_CarrierEndBank_BfGet(device, NULL, (adrv904x_BfChannelFilterChanAddr_e)channelFilterBaseAddr, carrierIdx, &dataPipeStop[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_ChannelFilter_CarrierBypassFilter_BfGet(device, NULL, (adrv904x_BfChannelFilterChanAddr_e)channelFilterBaseAddr, carrierIdx, &bypassFilter[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }
    }

    /* Assign per carrier variables */
    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        numHalfBandFilter[carrierIdx] = carrierConfigsOut->carrierCfgs.decimationRatio[carrierIdx];
        carrierSlots[carrierIdx] = 0U;
        carrierClkPeriod_ns[carrierIdx] = (1U << carrierConfigsOut->carrierCfgs.carrierRateRatio[carrierIdx]);
        if ((carriersEnabled & (1 << carrierIdx)) > 0U)
        {
            for (uint8_t s = 0U; s < ADRV904X_MAX_NO_OF_JESD_SLOTS; s++)
            {
                if (carrierDelayParams->slotTable[s] == carrierIdx)
                {
                    carrierSlots[carrierIdx] = s;
                    break;
                }
            }
        }
    }

    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        delays[carrierIdx].halfBandFilter.pipe = (carrierIdx % 4U) * 1U;
    }

    for (hb = ADRV904X_NO_OF_HALF_BAND_DELAYS; hb > 0U; hb--)
    {
        perStageCarrierEnable = 0U;
        
        for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
        {
            resourcePipe[carrierIdx].delay = delays[carrierIdx].halfBandFilter.pipe;
            resourcePipe[carrierIdx].period = numHalfBandFilter[carrierIdx] > hb ? (resourcePipe[carrierIdx].period << 1) : (int32_t)bandClkPeriod[carrierConfigsOut->carrierCfgs.bandSelect[carrierIdx] ? 1 : 0];
            perStageCarrierEnable |= numHalfBandFilter[carrierIdx] >= hb ? (carriersEnabled & (1U << carrierIdx)) : 0U;
        }
        for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
        {
            if (numHalfBandFilter[carrierIdx] >= hb)
            {
                mask = hb < ADRV904X_NO_OF_HALF_BAND_DELAYS ? 0xFFu : (carrierIdx < (ADI_ADRV904X_MAX_CARRIERS >> 1U)) ? 0x0Fu : 0xF0U;
                delays[carrierIdx].halfBandFilter.pipe += adrv904x_ResourceShareDelay(device, (perStageCarrierEnable & mask), resourcePipe, 1U, carrierIdx) + 2U;
            }
        }
    }

    /*  Accounting for resource share block used for gain multiplier */
    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        if ((carriersEnabled & (1 << carrierIdx)) > 0U)
        {
            delays[carrierIdx].channelFilter.pipe = adrv904x_CalculateChannelFilterDelay(device, dataPipeStop[carrierIdx], bypassFilter[carrierIdx], jesdClkPeriod_ns, carrierClkPeriod_ns[carrierIdx]);
            resourcePipe[carrierIdx].delay = delays[carrierIdx].channelFilter.pipe + delays[carrierIdx].halfBandFilter.pipe;
            resourcePipe[carrierIdx].period = carrierClkPeriod_ns[carrierIdx];
        }
    }

    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        if ((carriersEnabled & (1 << carrierIdx)) > 0U)
        {
            delays[carrierIdx].resource = adrv904x_ResourceShareDelay(device, carriersEnabled, resourcePipe, jesdClkPeriod_ns, carrierIdx);
        }
    }

    /*  hb filters , channel filter, interleaver delays */
    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        if ((carriersEnabled & (1 << carrierIdx)) > 0U)
        {
            if (bypassFilter[carrierIdx] == 0U)
            {                
                delays[carrierIdx].channelFilter.tap = ((carrierChannelFilter->numberOfFilterTaps[carrierIdx] - 1U) * carrierClkPeriod_ns[carrierIdx] >> 1);
                
                if (((carrierChannelFilter->numberOfFilterTaps[carrierIdx] - 1U) % 2) != 0)
                {
                    delays[carrierIdx].channelFilter.tap += (carrierClkPeriod_ns[carrierIdx] >> 1);
                }
            }

            delays[carrierIdx].halfBandFilter.tap = adrv904x_CalculateHalfBandFilterDelay(device, numHalfBandFilter[carrierIdx], carrierClkPeriod_ns[carrierIdx]);
            delays[carrierIdx].slotTable = carrierSlots[carrierIdx] * jesdClkPeriod_ns;
            totalDelay[carrierIdx] = delays[carrierIdx].channelFilter.tap + delays[carrierIdx].channelFilter.pipe +
                            delays[carrierIdx].halfBandFilter.tap + delays[carrierIdx].halfBandFilter.pipe +
                            delays[carrierIdx].delayMatchEnable +
                            delays[carrierIdx].slotTable +
                            delays[carrierIdx].resource;
            maxCarrierDelay = maxCarrierDelay > totalDelay[carrierIdx] ? maxCarrierDelay : totalDelay[carrierIdx];
        }
    }
    
    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        if ((carriersEnabled & (1 << carrierIdx)) > 0U)
        {
            delayDiff = maxCarrierDelay - totalDelay[carrierIdx];
            /*  Enable delay matching only if the delay offset is explictly greater than 0 .5 UI of the carrier. */
            /*  This is because enabling delay match adds more than the currently calculated delay to the carrier */
            /*  which would push it beyond the 0 .5 UI limit in this case */
            delays[carrierIdx].delayMatchEnable = ((delayDiff << 1U) > carrierClkPeriod_ns[carrierIdx]) ? 1U : 0U;
            /*  Extra delay due to delay match block */
            
            /* TODO: Put back when delay block is fixed
             * delays[carrierIdx].delayMatchEnable = delays[carrierIdx].delayMatchEnable * jesdClkPeriod_ns;
             * */
            delays[carrierIdx].delayMatchEnable = 0U;
        }
    }

    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        if ((carriersEnabled & (1 << carrierIdx)) > 0U)
        {
            resourcePipe[carrierIdx].delay = delays[carrierIdx].channelFilter.pipe + 
                                    delays[carrierIdx].halfBandFilter.pipe +
                                    delays[carrierIdx].delayMatchEnable;
        }
    }

    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        if ((carriersEnabled & (1 << carrierIdx)) > 0U)
        {
            delays[carrierIdx].resource = adrv904x_ResourceShareDelay(device, carriersEnabled, resourcePipe, jesdClkPeriod_ns, carrierIdx);
        }        
    }

    /*  Readjusting final delays */
    maxCarrierDelay = 0U;
    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        if ((carriersEnabled & (1 << carrierIdx)) > 0U)
        {
            totalDelay[carrierIdx] = delays[carrierIdx].channelFilter.tap + delays[carrierIdx].channelFilter.pipe +
                            delays[carrierIdx].halfBandFilter.tap + delays[carrierIdx].halfBandFilter.pipe +
                            delays[carrierIdx].delayMatchEnable +
                            delays[carrierIdx].slotTable +
                            delays[carrierIdx].resource;
            carrierDelayParams->carrierDelay[carrierIdx] = (uint16_t)totalDelay[carrierIdx];
        }
        else
        {
            carrierDelayParams->carrierDelay[carrierIdx] = 0;
        }
    }
    
    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_CducDelayCalculate(   adi_adrv904x_Device_t* const device, 
                                                                const adi_adrv904x_CarrierRadioCfg_t* const carrierConfigs,
                                                                adrv904x_CarrierDynamicReconfigProfileCfg_t* const carrierConfigsOut,
                                                                const adi_adrv904x_ChannelFilterOutputCfg_t* const carrierChannelFilter)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t i = 0U;
    uint32_t selectedChannel = 0U;
    uint32_t txIdx = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsOut);

    adrv904x_CarrierDelayParameters_t carrierDelay;

    ADI_LIBRARY_MEMSET(&carrierDelay, 0, sizeof(adrv904x_CarrierDelayParameters_t));

    carrierDelay.delayCmpEnable = 0U;
    carrierDelay.memoryEnable = 0U;
    carrierDelay.daisyChainEnable = 0U;

    for (i = 0; i < ADRV904X_NO_OF_CARRIER_DELAY_FIFOS; i++)
    {
        carrierDelay.carrierSelect[i] = 0U;
        carrierDelay.delayValue[i] = 0U;
    }

    carrierDelay.jesdIfaceFrequencyKhz = carrierConfigsOut->internalJesdCfg.frequencyKhz;
    carrierDelay.ratioLog2 = carrierConfigsOut->jesdCfg.jesdInterfaceClkDiv;

    for (i = 0; i < ADRV904X_MAX_NO_OF_JESD_SLOTS; i++)
    {
        carrierDelay.slotTable[i] = carrierConfigsOut->internalJesdCfg.ifaceSlotTable[i];
    }
    
    for (i = 0; i < ADI_ADRV904X_MAX_TXCHANNELS; i++)
    {
        if ((carrierConfigs->channelMask & (1 << i)) > 0)
        {
            selectedChannel = i;
            break;
        }
    }

    recoveryAction = adrv904x_CalculateCducCarrierDelay(device, selectedChannel, carrierConfigsOut, carrierChannelFilter, &carrierDelay);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    recoveryAction = adrv904x_CalculateDelayParameters(device, carrierConfigs, carrierConfigsOut, &carrierDelay);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    for (txIdx = 0U; txIdx < ADI_ADRV904X_MAX_TXCHANNELS; txIdx++)
    {
        if ((carrierConfigs->channelMask & (1U << txIdx)) > 0U)
        {
            /* TPGSWE-7944: Store calculated latency into device profile */
            //uint32_t clkCddcCducInkHz = carrierDelay.jesdIfaceFrequencyKhz * pow(2, carrierDelay.ratioLog2);
            uint32_t clkCddcCducInkHz = 12;
            device->devStateInfo.txCarrierLatencyCfg[txIdx].clkCddcCducInkHz = clkCddcCducInkHz;

            for (uint8_t carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
            {
                device->devStateInfo.txCarrierLatencyCfg[txIdx].groupDelay[carrierIdx] = carrierDelay.carrierDelay[carrierIdx];
            }
        }
        else
        {
            ADI_LIBRARY_MEMSET(&device->devStateInfo.txCarrierLatencyCfg[txIdx], 0, sizeof(adi_adrv904x_CarrierReconfigLatencyCfg_t));
        }
    }

    return recoveryAction; 
}


ADI_API adi_adrv904x_ErrAction_e adrv904x_CddcDelayCalculate(   adi_adrv904x_Device_t* const device, 
                                                                const adi_adrv904x_CarrierRadioCfg_t* const carrierConfigs,
                                                                adrv904x_CarrierDynamicReconfigProfileCfg_t* const carrierConfigsOut,
                                                                const adi_adrv904x_ChannelFilterOutputCfg_t* const carrierChannelFilter)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t i = 0U;
    uint32_t selectedChannel = 0U;
    uint32_t rxIdx = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsOut);
    
    adrv904x_CarrierDelayParameters_t carrierDelay;

    ADI_LIBRARY_MEMSET(&carrierDelay, 0, sizeof(adrv904x_CarrierDelayParameters_t));

    carrierDelay.delayCmpEnable = 0U;
    carrierDelay.memoryEnable = 0U;
    carrierDelay.daisyChainEnable = 0U;

    for (i = 0; i < ADRV904X_NO_OF_CARRIER_DELAY_FIFOS; i++)
    {
        carrierDelay.carrierSelect[i] = 0U;
        carrierDelay.delayValue[i] = 0U;
    }

    carrierDelay.jesdIfaceFrequencyKhz = carrierConfigsOut->internalJesdCfg.frequencyKhz;
    carrierDelay.ratioLog2 = carrierConfigsOut->jesdCfg.jesdInterfaceClkDiv;

    for (i = 0U; i < ADRV904X_MAX_NO_OF_JESD_SLOTS; i++)
    {
        carrierDelay.slotTable[i] = carrierConfigsOut->internalJesdCfg.ifaceSlotTable[i];
    }
    
    for (i = 0U; i < ADI_ADRV904X_MAX_RXCHANNELS; i++)
    {
        if ((carrierConfigs->channelMask & (1U << i)) > 0U)
        {
            selectedChannel = i;
            break;
        }
    }

    recoveryAction = adrv904x_CalculateCddcCarrierDelay(device, selectedChannel, carrierConfigsOut, carrierChannelFilter, &carrierDelay);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    recoveryAction = adrv904x_CalculateDelayParameters(device, carrierConfigs, carrierConfigsOut, &carrierDelay);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    for (rxIdx = 0U; rxIdx < ADI_ADRV904X_MAX_RX_ONLY; rxIdx++)
    {
        if ((carrierConfigs->channelMask & (1U << rxIdx)) > 0U)
        {
            /* TPGSWE-7944: Store calculated latency into device profile */
            //uint32_t clkCddcCducInkHz = carrierDelay.jesdIfaceFrequencyKhz * pow(2, carrierDelay.ratioLog2);
        	uint32_t clkCddcCducInkHz = carrierDelay.jesdIfaceFrequencyKhz;
            device->devStateInfo.rxCarrierLatencyCfg[rxIdx].clkCddcCducInkHz = clkCddcCducInkHz ;

            for (uint8_t carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
            {
                device->devStateInfo.rxCarrierLatencyCfg[rxIdx].groupDelay[carrierIdx] = carrierDelay.carrierDelay[carrierIdx] ;
            }
        }
        else
        {
            ADI_LIBRARY_MEMSET(&device->devStateInfo.rxCarrierLatencyCfg[rxIdx], 0, sizeof(adi_adrv904x_CarrierReconfigLatencyCfg_t));
        }
    }

    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_InternalReconfigStructInit(   adi_adrv904x_Device_t* const                        device,
                                                                        adrv904x_CarrierDynamicReconfigInternalCfg_t* const carrierConfigsOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    uint32_t i = 0U;
    uint32_t j = 0U;
    uint32_t p = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsOut);

    ADI_LIBRARY_MEMSET(carrierConfigsOut, 0, sizeof(adrv904x_CarrierDynamicReconfigInternalCfg_t));

    for (i = 0U; i < ADI_ADRV904X_MAX_CARRIER_LINKS; i++)
    {
        for (j = 0U; j < ADI_ADRV904X_MAX_CARRIER_SLOTS; j++)
        {
            carrierConfigsOut->carrierJesdCfg.linkCfg[i].jesdCfg[j].carrierXbarSelect.chanSelect = 0U;
            carrierConfigsOut->carrierJesdCfg.linkCfg[i].jesdCfg[j].carrierSelect                = ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR;
            carrierConfigsOut->carrierJesdCfg.linkCfg[i].jesdCfg[j].carrierXbarSelect.slotSelect = ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR;
        }
    }

    for (p = 0U; p < ADI_ADRV904X_MAX_NUM_PROFILES; p++)
    {
        for (i = 0U; i < ADRV904X_MAX_NO_OF_JESD_SLOTS; i++)
        {
            carrierConfigsOut->profileCfgs[p].internalJesdCfg.ifaceSlotTable[i] = (uint16_t)ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR;
        }

        for (i = 0U; i < ADRV904X_NO_OF_JESD_CARRIER_SLOTS; i++)
        {
            carrierConfigsOut->profileCfgs[p].jesdCfg.slotTable[i] = (uint16_t)ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR;
        }
    }

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_CarrierJesdParametersCalculate(   adi_adrv904x_Device_t* const                            device,
                                                                            const adi_adrv904x_CarrierRadioCfg_t* const             carrierConfigs,
                                                                            adrv904x_CarrierDynamicReconfigProfileCfg_t* const      carrierConfigsOut,
                                                                            const uint8_t                                           rxFlag)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t carrierIdx = 0U;
    uint32_t sumCarriersKhz = 0U;
    uint32_t minCarriersKhz = UINT32_MAX;
    uint32_t minIfaceKhz = ADRV904X_JESD_IQ_RATE_KHZ;
    uint32_t ratio = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigs);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsOut);

    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        if (carrierConfigs->carriers[carrierIdx].sampleRate_kHz > 0U)
        {
            if (rxFlag == ADI_TRUE)
            {
                carrierConfigsOut->carrierCfgs.interpolationRatio[carrierIdx]                       = adrv904x_SampleRateJesdIqRatioCalculate(carrierConfigs->carriers[carrierIdx].sampleRate_kHz);
                carrierConfigsOut->carrierCfgs.decimationRatio[carrierIdx]                          = adrv904x_CarrierBandSampleRateRatioCalculate(carrierConfigsOut->initialCfg.bandSettings[carrierConfigsOut->carrierCfgs.bandSelect[carrierIdx]].sampleRate_kHz, carrierConfigs->carriers[carrierIdx].sampleRate_kHz);
                carrierConfigsOut->internalJesdCfg.jesdSampleRate_kHz[carrierIdx]    = carrierConfigs->carriers[carrierIdx].sampleRate_kHz << carrierConfigsOut->carrierCfgs.interpolationRatio[carrierIdx];
            }
            else if (rxFlag == ADI_FALSE)
            {
                carrierConfigsOut->carrierCfgs.decimationRatio[carrierIdx]                          = adrv904x_SampleRateJesdIqRatioCalculate(carrierConfigs->carriers[carrierIdx].sampleRate_kHz);
                carrierConfigsOut->carrierCfgs.interpolationRatio[carrierIdx]                       = adrv904x_CarrierBandSampleRateRatioCalculate(carrierConfigsOut->initialCfg.bandSettings[carrierConfigsOut->carrierCfgs.bandSelect[carrierIdx]].sampleRate_kHz, carrierConfigs->carriers[carrierIdx].sampleRate_kHz);
                carrierConfigsOut->internalJesdCfg.jesdSampleRate_kHz[carrierIdx]    = carrierConfigs->carriers[carrierIdx].sampleRate_kHz << carrierConfigsOut->carrierCfgs.decimationRatio[carrierIdx];
            }
            else
            {
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, rxFlag, "Invalid rxFlag");
                return recoveryAction;
            }

            carrierConfigsOut->carrierCfgs.carrierRateRatio[carrierIdx] = adrv904x_CarrierRateCalculate(device->initExtract.clocks.hsDigClk_kHz, carrierConfigs->carriers[carrierIdx].sampleRate_kHz);

            sumCarriersKhz += carrierConfigsOut->internalJesdCfg.jesdSampleRate_kHz[carrierIdx];
            minCarriersKhz = carrierConfigs->carriers[carrierIdx].sampleRate_kHz < minCarriersKhz ? carrierConfigs->carriers[carrierIdx].sampleRate_kHz : minCarriersKhz;
        }
        else
        {
            carrierConfigsOut->carrierCfgs.interpolationRatio[carrierIdx]                       = 0U;
            carrierConfigsOut->carrierCfgs.decimationRatio[carrierIdx]                          = 0U;
            carrierConfigsOut->carrierCfgs.carrierRateRatio[carrierIdx]                         = 0U;
            carrierConfigsOut->internalJesdCfg.jesdSampleRate_kHz[carrierIdx]    = 0U;
        }
    }
    
    /* error checking */
    if (sumCarriersKhz > device->initExtract.clocks.hsDigClk_kHz)
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, sumCarriersKhz, "Aggregate carrier output sample rate exceeds the maximum value");
        return recoveryAction;
    }

    if (sumCarriersKhz == 0U)
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, sumCarriersKhz, "Invalid Configuration Parameter");
        return recoveryAction; 
    }

    ratio = device->initExtract.clocks.hsDigClk_kHz / sumCarriersKhz;
    carrierConfigsOut->jesdCfg.jesdInterfaceClkDiv = 0U;

    while (ratio > 1U)
    {
        carrierConfigsOut->jesdCfg.jesdInterfaceClkDiv++;
        ratio >>= 1U;
    }

    carrierConfigsOut->internalJesdCfg.divide = carrierConfigsOut->jesdCfg.jesdInterfaceClkDiv;
    carrierConfigsOut->internalJesdCfg.frequencyKhz = device->initExtract.clocks.hsDigClk_kHz >> carrierConfigsOut->jesdCfg.jesdInterfaceClkDiv;

    if (carrierConfigsOut->internalJesdCfg.frequencyKhz > ADRV904X_JESD_INTERFACE_MAX_FREQ_KHZ)
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT( &device->common,
                                recoveryAction,
                                carrierConfigsOut->internalJesdCfg.frequencyKhz,
                                "Component Carrier JESD interface rate exceeds the maximum value of 500000 kHz");
        return recoveryAction;
    }

    carrierConfigsOut->internalJesdCfg.numSlots = carrierConfigsOut->internalJesdCfg.frequencyKhz / minIfaceKhz;
    
    if (carrierConfigsOut->internalJesdCfg.numSlots <  carrierConfigsOut->initialCfg.maxSlot)
    {
        carrierConfigsOut->internalJesdCfg.numSlots = carrierConfigsOut->initialCfg.maxSlot;
        carrierConfigsOut->internalJesdCfg.frequencyKhz = carrierConfigsOut->internalJesdCfg.numSlots * minIfaceKhz;

        /* update jesd clk divider*/
        if (carrierConfigsOut->internalJesdCfg.frequencyKhz == 0U)
        {
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierConfigsOut->internalJesdCfg.frequencyKhz, "Invalid Configuration Parameter");
            return recoveryAction;
        }

        ratio = device->initExtract.clocks.hsDigClk_kHz / carrierConfigsOut->internalJesdCfg.frequencyKhz;
        carrierConfigsOut->jesdCfg.jesdInterfaceClkDiv = 0U;

        while (ratio > 1U)
        {
            carrierConfigsOut->jesdCfg.jesdInterfaceClkDiv++;
            ratio >>= 1U;
        }
    }
    else if (carrierConfigsOut->internalJesdCfg.numSlots > carrierConfigsOut->initialCfg.maxSlot)
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT( &device->common,
                                recoveryAction,
                                carrierConfigsOut->internalJesdCfg.numSlots,
                                "Cannot exceed the max slots used during initialization. Try initializing with a more robust profile created specifically for reconfiguring.");
        return recoveryAction;
    }

    /* Checking for maximum JESD iface slot value is in calculate_carrier_jesd_iface_slot_table */
    carrierConfigsOut->internalJesdCfg.ifaceMaxSlot = carrierConfigsOut->internalJesdCfg.numSlots;

    if (minCarriersKhz == 0U)
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, minCarriersKhz, "Invalid Configuration Parameter");
        return recoveryAction;
    }
    
    if (minIfaceKhz > minCarriersKhz)
    {
        carrierConfigsOut->internalJesdCfg.numSlots = (minIfaceKhz / minCarriersKhz);
        carrierConfigsOut->internalJesdCfg.numSlots *= carrierConfigsOut->internalJesdCfg.ifaceMaxSlot;
    }

    if (carrierConfigsOut->internalJesdCfg.ifaceMaxSlot > ADRV904X_MAX_NO_OF_JESD_SLOTS)
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierConfigsOut->internalJesdCfg.ifaceMaxSlot, "Number of Component Carrier Slots exceeds maximum");
        return recoveryAction;
    }

    recoveryAction = adrv904x_CarrierJesdSlotTableCalculate(device, carrierConfigs, carrierConfigsOut);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_RxCarrierBandSorting( adi_adrv904x_Device_t* const                        device,
                                                                const adi_adrv904x_CarrierRadioCfg_t* const         rxCarrierConfigs,
                                                                adrv904x_CarrierDynamicReconfigProfileCfg_t* const  rxCarrierConfigsOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, rxCarrierConfigs);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, rxCarrierConfigsOut);

    uint32_t band0LowerEdgeKhz      = rxCarrierConfigsOut->initialCfg.bandSettings[0U].rfCenterFreq_kHz - rxCarrierConfigsOut->initialCfg.bandSettings[0U].instBw_kHz / 2U;
    uint32_t band0UpperEdgeKhz      = rxCarrierConfigsOut->initialCfg.bandSettings[0U].rfCenterFreq_kHz + rxCarrierConfigsOut->initialCfg.bandSettings[0U].instBw_kHz / 2U;
    uint32_t band1LowerEdgeKhz      = rxCarrierConfigsOut->initialCfg.bandSettings[1U].rfCenterFreq_kHz - rxCarrierConfigsOut->initialCfg.bandSettings[1U].instBw_kHz / 2U;
    uint32_t band1UpperEdgeKhz      = rxCarrierConfigsOut->initialCfg.bandSettings[1U].rfCenterFreq_kHz + rxCarrierConfigsOut->initialCfg.bandSettings[1U].instBw_kHz / 2U;
    uint32_t carrierLowerEdgeKhz    = 0U;
    uint32_t carrierUpperEdgeKhz    = 0U;
    uint32_t idx                    = 0U;

    for (idx = 0; idx < ADI_ADRV904X_MAX_RX_CARRIERS; idx++)
    {
        if (rxCarrierConfigs->carriers[idx].enable)
        {
            rxCarrierConfigsOut->carriersEnabled |= (1 << idx);

            carrierLowerEdgeKhz = rxCarrierConfigs->carriers[idx].centerFrequency_kHz - rxCarrierConfigs->carriers[idx].ibw_kHz / 2;
            carrierUpperEdgeKhz = rxCarrierConfigs->carriers[idx].centerFrequency_kHz + rxCarrierConfigs->carriers[idx].ibw_kHz / 2;

            if ((carrierLowerEdgeKhz >= band0LowerEdgeKhz) && (carrierUpperEdgeKhz <= band0UpperEdgeKhz))
            {
                rxCarrierConfigsOut->carrierCfgs.bandSelect[idx] = 0U;
            }
            else if ((carrierLowerEdgeKhz >= band1LowerEdgeKhz) && (carrierUpperEdgeKhz <= band1UpperEdgeKhz))
            {
                rxCarrierConfigsOut->carrierCfgs.bandSelect[idx] = 1U;
            }
            else
            {
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, rxCarrierConfigs->carriers[idx].ibw_kHz, "Carrier is outside band");
                return recoveryAction;
            }
        }
    }

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_RxCarrierNcoReconfig( adi_adrv904x_Device_t* const                            device,
                                                                const adi_adrv904x_CarrierRadioCfg_t* const             rxCarrierConfigs,
                                                                adrv904x_CarrierDynamicReconfigProfileCfg_t* const        rxCarrierConfigsOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t idx = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, rxCarrierConfigs);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, rxCarrierConfigsOut);

    for (idx = 0; idx < ADI_ADRV904X_MAX_RX_CARRIERS; idx++)
    {
        if (rxCarrierConfigs->carriers[idx].enable)
        {
            rxCarrierConfigsOut->carrierCfgs.outputRate_kHz[idx]    = rxCarrierConfigsOut->initialCfg.bandSettings[rxCarrierConfigsOut->carrierCfgs.bandSelect[idx]].sampleRate_kHz;
            rxCarrierConfigsOut->carrierCfgs.ncoFreq_kHz[idx]       = rxCarrierConfigs->carriers[idx].centerFrequency_kHz
                                                                        - rxCarrierConfigsOut->initialCfg.bandSettings[rxCarrierConfigsOut->carrierCfgs.bandSelect[idx]].rfCenterFreq_kHz
                                                                            + rxCarrierConfigsOut->initialCfg.bandSettings[rxCarrierConfigsOut->carrierCfgs.bandSelect[idx]].bandOffset_kHz;

            rxCarrierConfigsOut->carrierCfgs.mixerEnable[idx]       = (rxCarrierConfigsOut->carrierCfgs.ncoFreq_kHz[idx] != 0) ? 1U : 0U;
        }
    }

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_RxCarrierDelaySet(    adi_adrv904x_Device_t* const device,
                                                                const uint8_t chanSelect,
                                                                const adrv904x_CarrierReconfigDelayParams_t* const rxDelayParams)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t rxSel = 0U;
    adrv904x_BfCddcHbDpathChanAddr_e cddcHbDpathChanBaseAddr = ADRV904X_BF_SLICE_RX_0__RX_CDDC_RX_CDDC_HB_DPATH;
    uint32_t delayRegisterIdx = 0U;
    uint32_t delayIdx = 0U;
    uint32_t delayRegOffset = ADRV904X_ADDR_RX0_CDDC_DELAY_0 - ADRV904X_BF_SLICE_RX_0__RX_CDDC_RX_CDDC_HB_DPATH;
    uint32_t delayRegAddr = 0U;
    uint32_t delayRegisterValue = 0U;
    uint32_t fifoSelectIdx = 0U;
    const uint32_t DELAY_VAL_MASK = 0x1FFU;
    const uint32_t DELAY_VAL_SHIFT = 16U;
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, rxDelayParams);   

    /* Convert the rxSel to the base address value required by the bitfield functions */
    rxSel = 1U << chanSelect;
    recoveryAction = adrv904x_CddcHbDpathBitfieldAddressGet(device, (adi_adrv904x_RxChannels_e)(rxSel), &cddcHbDpathChanBaseAddr);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    

    recoveryAction = adrv904x_CddcHbDpath_DelayCmpEn_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxDelayParams->delayCmpEnable);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_DelayMemEn_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxDelayParams->delayMemEnable);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_DaisyChainEn_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxDelayParams->daisyChainEnable);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_CarrierSelect0_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxDelayParams->delayCarrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_CarrierSelect1_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxDelayParams->delayCarrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_CarrierSelect2_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxDelayParams->delayCarrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_CarrierSelect3_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxDelayParams->delayCarrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_CarrierSelect4_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxDelayParams->delayCarrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_CarrierSelect5_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxDelayParams->delayCarrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_CarrierSelect6_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxDelayParams->delayCarrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_CarrierSelect7_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxDelayParams->delayCarrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    /* HBDpath base + SlotValue0 offset */
    delayRegAddr = (uint32_t)cddcHbDpathChanBaseAddr + delayRegOffset;
    for (delayRegisterIdx = 0U; delayRegisterIdx < (ADRV904X_NO_OF_CARRIER_DELAY_FIFOS >> 1); delayRegisterIdx++)
    {
        delayRegisterValue = ((uint32_t)rxDelayParams->delayValue[delayIdx++] & DELAY_VAL_MASK);
        delayRegisterValue |= ((uint32_t)(rxDelayParams->delayValue[delayIdx++] & DELAY_VAL_MASK) << DELAY_VAL_SHIFT);

        recoveryAction = adi_adrv904x_Register32Write(device, NULL, delayRegAddr, delayRegisterValue, 0xFFFFFFFFU);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }
        delayRegAddr += 4U;
    }
    
    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_RxCarrierConfigSet( adi_adrv904x_Device_t* const                                  device,
                                                                const uint8_t                                               chanSelect,
                                                                const adrv904x_CarrierDynamicReconfigProfileCfg_t* const   rxCarrierConfigs)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    adrv904x_BfCddcHbDpathChanAddr_e cddcHbDpathChanBaseAddr = ADRV904X_BF_SLICE_RX_0__RX_CDDC_RX_CDDC_HB_DPATH;
    uint32_t carrierIdx = 0U;
    uint32_t rxSel = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, rxCarrierConfigs);

    if (chanSelect > (ADI_ADRV904X_MAX_RX_ONLY - 1U))
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, chanSelect, "Invalid RX Channel");
        return recoveryAction; 
    }

    /* Convert the rxSel to the base address value required by the bitfield functions */
    rxSel = 1U << chanSelect;
    recoveryAction = adrv904x_CddcHbDpathBitfieldAddressGet(device, (adi_adrv904x_RxChannels_e)(rxSel), &cddcHbDpathChanBaseAddr);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    recoveryAction = adrv904x_CddcHbDpath_CarrierEnable_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxCarrierConfigs->carriersEnabled);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    for (carrierIdx = 0; carrierIdx < ADI_ADRV904X_MAX_RX_CARRIERS; carrierIdx++)
    {
        recoveryAction = adrv904x_CddcHbDpath_OneMsClocks_BfSet(device, NULL, cddcHbDpathChanBaseAddr, carrierIdx, rxCarrierConfigs->carrierCfgs.outputRate_kHz[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CddcHbDpath_BandSource_BfSet(device, NULL, cddcHbDpathChanBaseAddr, carrierIdx, (adrv904x_Bf_CddcHbDpath_BandSource_e)rxCarrierConfigs->carrierCfgs.bandSelect[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CddcHbDpath_FreqKhz_BfSet(device, NULL, cddcHbDpathChanBaseAddr, carrierIdx, rxCarrierConfigs->carrierCfgs.ncoFreq_kHz[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CddcHbDpath_NcoFtwUpdate_BfSet(device, NULL, cddcHbDpathChanBaseAddr, carrierIdx, 1U);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CddcHbDpath_NcoEnable_BfSet(device, NULL, cddcHbDpathChanBaseAddr, carrierIdx, rxCarrierConfigs->carrierCfgs.mixerEnable[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CddcHbDpath_MixerEn_BfSet(device, NULL, cddcHbDpathChanBaseAddr, carrierIdx, rxCarrierConfigs->carrierCfgs.mixerEnable[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }
    }

    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_TxCarrierBandSorting( adi_adrv904x_Device_t* const                        device,
                                                                const adi_adrv904x_CarrierRadioCfg_t* const         txCarrierConfigs,
                                                                adrv904x_CarrierDynamicReconfigProfileCfg_t* const  txCarrierConfigsOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, txCarrierConfigs);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, txCarrierConfigsOut);

    uint32_t band0LowerEdgeKhz      = txCarrierConfigsOut->initialCfg.bandSettings[0U].rfCenterFreq_kHz - txCarrierConfigsOut->initialCfg.bandSettings[0U].instBw_kHz / 2U;
    uint32_t band0UpperEdgeKhz      = txCarrierConfigsOut->initialCfg.bandSettings[0U].rfCenterFreq_kHz + txCarrierConfigsOut->initialCfg.bandSettings[0U].instBw_kHz / 2U;
    uint32_t band1LowerEdgeKhz      = txCarrierConfigsOut->initialCfg.bandSettings[1U].rfCenterFreq_kHz - txCarrierConfigsOut->initialCfg.bandSettings[1U].instBw_kHz / 2U;
    uint32_t band1UpperEdgeKhz      = txCarrierConfigsOut->initialCfg.bandSettings[1U].rfCenterFreq_kHz + txCarrierConfigsOut->initialCfg.bandSettings[1U].instBw_kHz / 2U;
    uint32_t carrierLowerEdgeKhz    = 0U;
    uint32_t carrierUpperEdgeKhz    = 0U;
    uint32_t idx                    = 0U;

    for (idx = 0; idx < ADI_ADRV904X_MAX_CARRIERS; idx++)
    {
        if (txCarrierConfigs->carriers[idx].enable)
        {
            txCarrierConfigsOut->carriersEnabled |= (1 << idx);

            carrierLowerEdgeKhz = txCarrierConfigs->carriers[idx].centerFrequency_kHz - txCarrierConfigs->carriers[idx].ibw_kHz / 2;
            carrierUpperEdgeKhz = txCarrierConfigs->carriers[idx].centerFrequency_kHz + txCarrierConfigs->carriers[idx].ibw_kHz / 2;

            if ((carrierLowerEdgeKhz >= band0LowerEdgeKhz) && (carrierUpperEdgeKhz <= band0UpperEdgeKhz))
            {
                txCarrierConfigsOut->carrierCfgs.bandSelect[idx] = 0U;
            }
            else if ((carrierLowerEdgeKhz >= band1LowerEdgeKhz) && (carrierUpperEdgeKhz <= band1UpperEdgeKhz))
            {
                txCarrierConfigsOut->carrierCfgs.bandSelect[idx] = 1U;
            }
            else
            {
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, txCarrierConfigs->carriers[idx].ibw_kHz, "Carrier is outside band");
                return recoveryAction;
            }
        }
    }

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_TxCarrierNcoReconfig( adi_adrv904x_Device_t* const                            device,
                                                                const adi_adrv904x_CarrierRadioCfg_t* const   txCarrierConfigs,
                                                                adrv904x_CarrierDynamicReconfigProfileCfg_t* const   txCarrierConfigsOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t idx = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, txCarrierConfigs);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, txCarrierConfigsOut);

    for (idx = 0; idx < ADI_ADRV904X_MAX_CARRIERS; idx++)
    {
        if (txCarrierConfigs->carriers[idx].enable)
        {
            txCarrierConfigsOut->carrierCfgs.outputRate_kHz[idx] = txCarrierConfigsOut->initialCfg.bandSettings[txCarrierConfigsOut->carrierCfgs.bandSelect[idx]].sampleRate_kHz;
            txCarrierConfigsOut->carrierCfgs.ncoFreq_kHz[idx] = txCarrierConfigs->carriers[idx].centerFrequency_kHz - txCarrierConfigsOut->initialCfg.bandSettings[txCarrierConfigsOut->carrierCfgs.bandSelect[idx]].rfCenterFreq_kHz;
            txCarrierConfigsOut->carrierCfgs.mixerEnable[idx] = (txCarrierConfigsOut->carrierCfgs.ncoFreq_kHz[idx] != 0) ? 1U : 0U;
        }
    }

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_TxCarrierBandAttenConfig( adi_adrv904x_Device_t* const                        device,
                                                                    const adi_adrv904x_CarrierRadioCfg_t* const         txCarrierConfigs,
                                                                    adrv904x_CarrierDynamicReconfigProfileCfg_t* const  txCarrierConfigsOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t idx = 0U;

    uint8_t carrierCnt = 0U;
    uint16_t attenVals[] = 
    {
        181U,   /* 256.0 / sqrt(2) */
        147U,   /* 256.0 / sqrt(3) */
        128U,   /* 256.0 / sqrt(4) */
        114U,   /* 256.0 / sqrt(5) */
        104U,   /* 256.0 / sqrt(6) */
        96U,    /* 256.0 / sqrt(7) */
        90U,    /* 256.0 / sqrt(8) */
    };

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, txCarrierConfigs);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, txCarrierConfigsOut);

    for (idx = 0; idx < ADI_ADRV904X_MAX_CARRIERS; idx++)
    {
        if (txCarrierConfigs->carriers[idx].enable)
        {
            carrierCnt++;
        }
    }

    /* Use pre-calculated atten values in the array offset by two for correct indexing */
    txCarrierConfigsOut->band0Atten = (carrierCnt > 1U) ? attenVals[carrierCnt - 2U] : UINT16_MAX;

    /* Band attenuation value must match to ensure full scale is not exceeded after the summation of DUC0 and DUC 1 */
    txCarrierConfigsOut->band1Atten = txCarrierConfigsOut->band0Atten;

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_TxCarrierDelaySet(    adi_adrv904x_Device_t* const device,
                                                                const uint8_t chanSelect,
                                                                const adrv904x_CarrierReconfigDelayParams_t* const txDelayParams)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t txSel = 0U;
    adrv904x_BfCducHbDpathChanAddr_e cducHbDpathChanBaseAddr = ADRV904X_BF_SLICE_TX_0__TX_CDUC_TX_CDUC_HB_DPATH;
    uint32_t delayRegisterIdx = 0U;
    uint32_t delayIdx = 0U;
    uint32_t delayRegOffset = ADRV904X_ADDR_TX0_CDDC_DELAY_0 - ADRV904X_BF_SLICE_TX_0__TX_CDUC_TX_CDUC_HB_DPATH;
    uint32_t delayRegAddr = 0U;
    uint32_t delayRegisterValue = 0U;
    uint32_t fifoSelectIdx = 0U;
    const uint32_t DELAY_VAL_MASK = 0x1FFU;
    const uint32_t DELAY_VAL_SHIFT = 16U;
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, txDelayParams);   

    /* Convert the txSel to the base address value required by the bitfield functions */
    txSel = 1U << chanSelect;
    recoveryAction = adrv904x_CducHbDpathBitfieldAddressGet(device, (adi_adrv904x_TxChannels_e)(txSel), &cducHbDpathChanBaseAddr);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    

    recoveryAction = adrv904x_CducHbDpath_DelayCompEn_BfSet(device, NULL, cducHbDpathChanBaseAddr, txDelayParams->delayCmpEnable);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_DelayMemEn_BfSet(device, NULL, cducHbDpathChanBaseAddr, txDelayParams->delayMemEnable);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_DaisyChainEn_BfSet(device, NULL, cducHbDpathChanBaseAddr, txDelayParams->daisyChainEnable);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_CarrierSelect0_BfSet(device, NULL, cducHbDpathChanBaseAddr, txDelayParams->delayCarrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_CarrierSelect1_BfSet(device, NULL, cducHbDpathChanBaseAddr, txDelayParams->delayCarrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_CarrierSelect2_BfSet(device, NULL, cducHbDpathChanBaseAddr, txDelayParams->delayCarrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_CarrierSelect3_BfSet(device, NULL, cducHbDpathChanBaseAddr, txDelayParams->delayCarrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_CarrierSelect4_BfSet(device, NULL, cducHbDpathChanBaseAddr, txDelayParams->delayCarrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_CarrierSelect5_BfSet(device, NULL, cducHbDpathChanBaseAddr, txDelayParams->delayCarrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_CarrierSelect6_BfSet(device, NULL, cducHbDpathChanBaseAddr, txDelayParams->delayCarrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_CarrierSelect7_BfSet(device, NULL, cducHbDpathChanBaseAddr, txDelayParams->delayCarrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    /* HBDpath base + SlotValue0 offset */
    delayRegAddr = (uint32_t)cducHbDpathChanBaseAddr + delayRegOffset;
    for (delayRegisterIdx = 0U; delayRegisterIdx < (ADRV904X_NO_OF_CARRIER_DELAY_FIFOS >> 1); delayRegisterIdx++)
    {
        delayRegisterValue = ((uint32_t)txDelayParams->delayValue[delayIdx++] & DELAY_VAL_MASK);
        delayRegisterValue |= ((uint32_t)(txDelayParams->delayValue[delayIdx++] & DELAY_VAL_MASK) << DELAY_VAL_SHIFT);

        recoveryAction = adi_adrv904x_Register32Write(device, NULL, delayRegAddr, delayRegisterValue, 0xFFFFFFFFU);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }
        delayRegAddr += 4U;
    }
    
    return recoveryAction;
}
ADI_API adi_adrv904x_ErrAction_e adrv904x_TxCarrierConfigSet(   adi_adrv904x_Device_t* const                                device,
                                                                const uint8_t                                               chanSelect,
                                                                const adrv904x_CarrierDynamicReconfigProfileCfg_t* const txCarrierConfigs)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    adrv904x_BfCducHbDpathChanAddr_e cducHbDpathChanBaseAddr = ADRV904X_BF_SLICE_TX_0__TX_CDUC_TX_CDUC_HB_DPATH;
    uint32_t carrierIdx = 0U;
    uint32_t txSel = 0U;

    /* Check device pointer is not null */
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, txCarrierConfigs);

    if (chanSelect > ADI_ADRV904X_TX_CHAN_ID_MAX)
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, chanSelect, "Invalid TX Channel");
        return recoveryAction; 
    }

    /* Convert the txSel to the base address value required by the bitfield functions */
    txSel = 1U << chanSelect;
    recoveryAction = adrv904x_CducHbDpathBitfieldAddressGet(device, (adi_adrv904x_TxChannels_e)(txSel), &cducHbDpathChanBaseAddr);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    for (carrierIdx = 0; carrierIdx < ADI_ADRV904X_MAX_RX_CARRIERS; carrierIdx++)
    {
        recoveryAction = adrv904x_CducHbDpath_OneMsClocks_BfSet(device,
                                                                NULL,
                                                                cducHbDpathChanBaseAddr,
                                                                carrierIdx,
                                                                txCarrierConfigs->carrierCfgs.outputRate_kHz[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CducHbDpath_BandDest_BfSet(   device,
                                                                NULL,
                                                                cducHbDpathChanBaseAddr,
                                                                carrierIdx,
                                                                (adrv904x_Bf_CducHbDpath_BandDest_e)txCarrierConfigs->carrierCfgs.bandSelect[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CducHbDpath_FreqKhz_BfSet(device,
                                                            NULL,
                                                            cducHbDpathChanBaseAddr,
                                                            carrierIdx,
                                                            (uint32_t)txCarrierConfigs->carrierCfgs.ncoFreq_kHz[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CducHbDpath_NcoFtwUpdate_BfSet(   device,
                                                                    NULL,
                                                                    cducHbDpathChanBaseAddr,
                                                                    carrierIdx,
                                                                    1U);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CducHbDpath_NcoEnable_BfSet(  device,
                                                                NULL,
                                                                cducHbDpathChanBaseAddr,
                                                                carrierIdx,
                                                                txCarrierConfigs->carrierCfgs.mixerEnable[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CducHbDpath_MixerEn_BfSet(device,
                                                            NULL,
                                                            cducHbDpathChanBaseAddr,
                                                            carrierIdx,
                                                            txCarrierConfigs->carrierCfgs.mixerEnable[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }
    }

    recoveryAction = adrv904x_CducHbDpath_CarrBand0Attn_BfSet(  device,
                                                                NULL,
                                                                cducHbDpathChanBaseAddr,
                                                                txCarrierConfigs->band0Atten);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    recoveryAction = adrv904x_CducHbDpath_CarrBand1Attn_BfSet(  device,
                                                                NULL,
                                                                cducHbDpathChanBaseAddr,
                                                                txCarrierConfigs->band1Atten);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    recoveryAction = adrv904x_CducHbDpath_CducCarrierEnable_BfSet(  device,
                                                                    NULL,
                                                                    cducHbDpathChanBaseAddr,
                                                                    txCarrierConfigs->carriersEnabled);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    return recoveryAction;
}
ADI_API adi_adrv904x_ErrAction_e adrv904x_RxJesdConfigSet(  adi_adrv904x_Device_t* const                                device,
                                                            const adrv904x_CarrierDynamicReconfigInternalCfg_t* const   rxCarrierConfigs)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t linkIdx = 0U;
    uint8_t xbarControlIdx = 0U;
    uint32_t xbarControlMax = ADI_ADRV904X_MAX_CARRIER_SLOTS;
    uint32_t jtxConvDisable = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, rxCarrierConfigs);

    for (linkIdx = 0U; linkIdx < ADI_ADRV904X_MAX_CARRIER_LINKS; linkIdx++)
    {

        xbarControlMax = (linkIdx == 0U) ? ADI_ADRV904X_MAX_CARRIER_SLOTS : ADI_ADRV904X_MAX_CARRIER_SLOTS >> 1U;
        for (xbarControlIdx = 0U; xbarControlIdx < xbarControlMax; xbarControlIdx++)
        {
            if (rxCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect > ADRV904X_LAST_VALID_SLOT_SELECT_IN_CARRIER_MODE)
            {
                jtxConvDisable = 1U; /* 1 is an invalid entry */
            }
            else
            {
                jtxConvDisable = 0U; /* 0 is a valid entry */
            }
            
            if (linkIdx == 0U)
            {
                recoveryAction = adrv904x_JesdCommon_JtxCoreConvDisableLink0_BfSet( device,
                                                                                    NULL,
                                                                                    ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                    xbarControlIdx,
                                                                                    jtxConvDisable);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_JtxChannelSelLink0_BfSet(  device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                rxCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.chanSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
                
                recoveryAction = adrv904x_JesdCommon_Rx0ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                rxCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
                
                recoveryAction = adrv904x_JesdCommon_Rx1ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                rxCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx2ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                rxCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx3ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                rxCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx4ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                rxCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx5ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                rxCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx6ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                rxCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx7ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                rxCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
            }
            else
            {
                recoveryAction = adrv904x_JesdCommon_JtxCoreConvDisableLink1_BfSet( device,
                                                                                    NULL,
                                                                                    ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                    xbarControlIdx,
                                                                                    jtxConvDisable);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_JtxChannelSelLink1_BfSet(  device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                rxCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.chanSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx0ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                rxCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx1ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                rxCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx2ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                rxCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx3ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                rxCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx4ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                rxCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx5ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                rxCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx6ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                rxCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx7ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                rxCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
            }
        }
    }

    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_CarrierRxJesdConfigSet(   adi_adrv904x_Device_t* const                                device,
                                                                    const uint32_t                                              rxChannelMask,
                                                                    const adrv904x_CarrierDynamicReconfigProfileCfg_t* const   rxCarrierConfigs)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    adrv904x_BfCddcHbDpathChanAddr_e cddcHbDpathChanBaseAddr = ADRV904X_BF_SLICE_RX_0__RX_CDDC_RX_CDDC_HB_DPATH;
    uint32_t carrierIdx = 0U;
    uint32_t rxIdx = 0U;
    uint32_t rxSel = 0U;
    uint32_t slotRegisterIdx = 0U;
    uint32_t slotIdx = 0U;
    uint32_t slotAddr = 0U;
    uint32_t slotRegOffset = ADRV904X_ADDR_RX0_INTERLEAVER_SLOT_TABLE_0 - ADRV904X_BF_SLICE_RX_0__RX_CDDC_RX_CDDC_HB_DPATH;
    uint32_t slotRegisterValue = 0U;
    adrv904x_BfCddcFuncsChanAddr_e cddcFuncAddr = (adrv904x_BfCddcFuncsChanAddr_e) 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, rxCarrierConfigs);

    /* rxChannelMask should larger than 0 and less than 0x100 */
    if ((rxChannelMask == 0U) ||
        ((rxChannelMask & (~(uint32_t)ADI_ADRV904X_RX_MASK_ALL)) != 0U))
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, rxChannelMask, "Invalid Rx channel mask");
        return recoveryAction;
    }

    for (rxIdx = 0U; rxIdx < ADI_ADRV904X_MAX_RX_ONLY; rxIdx++)
    {
        rxSel = 1U << rxIdx;
        if ((rxChannelMask & rxSel) > 0U)
        {
            cddcFuncAddr = (adrv904x_BfCddcFuncsChanAddr_e) (ADRV904X_BF_SLICE_RX_0__RX_CDDC_RX_CDDC_FUNCS
                                                             + (ADRV904X_BF_SLICE_RX_1__RX_CDDC_RX_CDDC_FUNCS - ADRV904X_BF_SLICE_RX_0__RX_CDDC_RX_CDDC_FUNCS) * rxIdx);

            recoveryAction = adrv904x_CddcFuncs_CddcJesdClkDiv_BfSet(   device,
                                                                        NULL,
                                                                        cddcFuncAddr,
                                                                        (adrv904x_Bf_CddcFuncs_CddcJesdClkDiv_e)rxCarrierConfigs->jesdCfg.jesdInterfaceClkDiv);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            recoveryAction = adrv904x_CddcHbDpathBitfieldAddressGet(device,
                                                                    (adi_adrv904x_RxChannels_e)(rxSel),
                                                                    &cddcHbDpathChanBaseAddr);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            recoveryAction = adrv904x_CddcHbDpath_InterleaverMaxSlot_BfSet( device,
                                                                            NULL,
                                                                            cddcHbDpathChanBaseAddr,
                                                                            rxCarrierConfigs->internalJesdCfg.ifaceMaxSlot);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            recoveryAction = adrv904x_CddcHbDpath_InterleaverSlotValidLower_BfSet(  device,
                                                                                    NULL,
                                                                                    cddcHbDpathChanBaseAddr,
                                                                                    rxCarrierConfigs->jesdCfg.slotValidLower);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            recoveryAction = adrv904x_CddcHbDpath_InterleaverSlotValidUpper_BfSet(  device,
                                                                                    NULL,
                                                                                    cddcHbDpathChanBaseAddr,
                                                                                    rxCarrierConfigs->jesdCfg.slotValidUpper);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            /* HBDpath base + SlotValue0 offset */
            slotAddr = (uint32_t)cddcHbDpathChanBaseAddr + slotRegOffset;
            for (slotRegisterIdx = 0U; slotRegisterIdx < (ADRV904X_NO_OF_JESD_CARRIER_SLOTS / ADRV904X_SLOTS_PER_REGISTER); slotRegisterIdx++)
            {
                slotRegisterValue = 0U;
                if (slotRegisterIdx < 2)
                {
                for (slotIdx = 0U; slotIdx < ADRV904X_SLOTS_PER_REGISTER; slotIdx++)
                {
                        slotRegisterValue |= (rxCarrierConfigs->internalJesdCfg.ifaceSlotTable[(slotRegisterIdx * ADRV904X_SLOTS_PER_REGISTER + slotIdx)] & 0xFU) << (4U * slotIdx);
                    } 
                }

                recoveryAction = adi_adrv904x_Register32Write(device, NULL, slotAddr, slotRegisterValue, 0xFFFFFFFFU);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
                slotAddr += 4U;
            }

            for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
            {
                recoveryAction = adrv904x_CddcHbDpath_UpsamplerRatio_BfSet( device,
                                                                            NULL,
                                                                            cddcHbDpathChanBaseAddr,
                                                                            carrierIdx,
                                                                            (adrv904x_Bf_CddcHbDpath_UpsamplerRatio_e)rxCarrierConfigs->carrierCfgs.interpolationRatio[carrierIdx]);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_CddcHbDpath_DecRate_BfSet(device,
                                                                    NULL,
                                                                    cddcHbDpathChanBaseAddr,
                                                                    carrierIdx,
                                                                    (adrv904x_Bf_CddcHbDpath_DecRate_e)rxCarrierConfigs->carrierCfgs.decimationRatio[carrierIdx]);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
            }
        }
    }

    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_TxJesdConfigSet(  adi_adrv904x_Device_t* const                                device,
                                                            const adrv904x_CarrierDynamicReconfigInternalCfg_t* const   txCarrierConfigs)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t linkIdx = 0U;
    uint8_t xbarControlIdx = 0U;
    uint32_t xbarControlMax = ADI_ADRV904X_MAX_CARRIER_SLOTS;
    uint32_t jrxConvDisable = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, txCarrierConfigs);

    for (linkIdx = 0U; linkIdx < ADI_ADRV904X_MAX_CARRIER_LINKS; linkIdx++)
    {
        xbarControlMax = (linkIdx == 0U) ? ADI_ADRV904X_MAX_CARRIER_SLOTS : ADI_ADRV904X_MAX_CARRIER_SLOTS >> 1U;

        for (xbarControlIdx = 0U; xbarControlIdx < xbarControlMax; xbarControlIdx++)
        {
            if (txCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect > ADRV904X_LAST_VALID_SLOT_SELECT_IN_CARRIER_MODE)
            {
                jrxConvDisable = 1U; /* 1 is an invalid entry */
            }
            else
            {
                jrxConvDisable = 0U; /* 0 is a valid entry */
            }

            if (linkIdx == 0U)
            {
                recoveryAction = adrv904x_JesdCommon_JrxCoreConvDisableLink0_BfSet( device,
                                                                                    NULL,
                                                                                    ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                    xbarControlIdx,
                                                                                    jrxConvDisable);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_JrxChannelSelLink0_BfSet(  device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                txCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.chanSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx0ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                txCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx1ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                txCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx2ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                txCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx3ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                txCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx4ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                txCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx5ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                txCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx6ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                txCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx7ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                txCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
            }
            else
            {
                recoveryAction = adrv904x_JesdCommon_JrxCoreConvDisableLink1_BfSet( device,
                                                                                    NULL,
                                                                                    ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                    xbarControlIdx,
                                                                                    jrxConvDisable);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_JrxChannelSelLink1_BfSet(  device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                txCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.chanSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx0ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                txCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx1ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                txCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx2ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                txCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx3ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                txCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx4ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                txCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx5ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                txCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx6ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                txCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx7ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                txCarrierConfigs->carrierJesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].carrierXbarSelect.slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
            }
        }
    }

    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_CarrierTxJesdConfigSet(   adi_adrv904x_Device_t* const                                device,
                                                                    const uint32_t                                              txChannelMask,
                                                                    const adrv904x_CarrierDynamicReconfigProfileCfg_t* const   txCarrierConfigs)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    adrv904x_BfCducHbDpathChanAddr_e cducHbDpathChanBaseAddr = ADRV904X_BF_SLICE_TX_0__TX_CDUC_TX_CDUC_HB_DPATH;
    uint32_t carrierIdx = 0U;
    uint32_t txIdx = 0U;
    uint32_t txSel = 0U;
    uint32_t slotRegisterIdx = 0U;
    uint32_t slotIdx = 0U;
    uint32_t slotAddr = 0U;
    uint32_t slotRegOffset = ADRV904X_ADDR_TX0_DEINTERLEAVER_SLOT_TABLE_0 - ADRV904X_BF_SLICE_TX_0__TX_CDUC_TX_CDUC_HB_DPATH;
    uint32_t slotRegisterValue = 0U;
    adrv904x_BfCducFuncsChanAddr_e cducFuncAddr = (adrv904x_BfCducFuncsChanAddr_e) 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, txCarrierConfigs);

    /* txChannelMask should larger than 0 and less than 0x100 */
    if ((txChannelMask == 0U) ||
        ((txChannelMask & (~(uint32_t)ADI_ADRV904X_TXALL)) != 0U))
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, txChannelMask, "Invalid Tx channel mask");
        return recoveryAction;
    }

    for (txIdx = 0U; txIdx < ADI_ADRV904X_MAX_TXCHANNELS; txIdx++)
    {
        txSel = 1U << txIdx;
        if ((txChannelMask & txSel) > 0U)
        {
            cducFuncAddr = (adrv904x_BfCducFuncsChanAddr_e) (ADRV904X_BF_SLICE_TX_0__TX_CDUC_TX_CDUC_FUNCS
                                + (ADRV904X_BF_SLICE_TX_1__TX_CDUC_TX_CDUC_FUNCS - ADRV904X_BF_SLICE_TX_0__TX_CDUC_TX_CDUC_FUNCS) * txIdx);

            recoveryAction = adrv904x_CducFuncs_CducJesdClkDiv_BfSet(   device,
                                                                        NULL,
                                                                        cducFuncAddr,
                                                                        (adrv904x_Bf_CducFuncs_CducJesdClkDiv_e)txCarrierConfigs->jesdCfg.jesdInterfaceClkDiv);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            recoveryAction = adrv904x_CducHbDpathBitfieldAddressGet(device,
                                                                    (adi_adrv904x_TxChannels_e)(txSel),
                                                                    &cducHbDpathChanBaseAddr);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            recoveryAction = adrv904x_CducHbDpath_DeinterleaverMaxSlot_BfSet(   device,
                                                                                NULL,
                                                                                cducHbDpathChanBaseAddr,
                                                                                txCarrierConfigs->internalJesdCfg.numSlots);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            recoveryAction = adrv904x_CducHbDpath_DeinterleaverSlotValidLower_BfSet(device,
                                                                                    NULL,
                                                                                    cducHbDpathChanBaseAddr,
                                                                                    txCarrierConfigs->jesdCfg.slotValidLower);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            recoveryAction = adrv904x_CducHbDpath_DeinterleaverSlotValidUpper_BfSet(device,
                                                                                    NULL,
                                                                                    cducHbDpathChanBaseAddr,
                                                                                    txCarrierConfigs->jesdCfg.slotValidUpper);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            /* HBDpath base + SlotValue0 offset */
            slotAddr = (uint32_t)cducHbDpathChanBaseAddr + slotRegOffset;
            for (slotRegisterIdx = 0U; slotRegisterIdx < (ADRV904X_NO_OF_JESD_CARRIER_SLOTS / ADRV904X_SLOTS_PER_REGISTER); slotRegisterIdx++)
            {
                slotRegisterValue = 0U;

                for (slotIdx = 0U; slotIdx < ADRV904X_SLOTS_PER_REGISTER; slotIdx++)
                {
                    slotRegisterValue |= (txCarrierConfigs->jesdCfg.slotTable[(slotRegisterIdx * ADRV904X_SLOTS_PER_REGISTER + slotIdx)] & 0xFU) << (4U * slotIdx);
                }

                recoveryAction = adi_adrv904x_Register32Write(device, NULL, slotAddr, slotRegisterValue, 0xFFFFFFFFU);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
                slotAddr += 4U;
            }

            for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
            {
                recoveryAction = adrv904x_CducHbDpath_DownsamplerRatio_BfSet(   device,
                                                                                NULL,
                                                                                cducHbDpathChanBaseAddr,
                                                                                carrierIdx,
                                                                                (adrv904x_Bf_CducHbDpath_DownsamplerRatio_e)txCarrierConfigs->carrierCfgs.decimationRatio[carrierIdx]);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_CducHbDpath_IntRate_BfSet(device,
                                                                    NULL,
                                                                    cducHbDpathChanBaseAddr,
                                                                    carrierIdx,
                                                                    (adrv904x_Bf_CducHbDpath_IntRate_e)txCarrierConfigs->carrierCfgs.interpolationRatio[carrierIdx]);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_CducHbDpath_CducClkToCarrierRate_BfSet(   device,
                                                                                    NULL,
                                                                                    cducHbDpathChanBaseAddr,
                                                                                    carrierIdx,
                                                                                    (adrv904x_Bf_CducHbDpath_CducClkToCarrierRate_e)txCarrierConfigs->carrierCfgs.carrierRateRatio[carrierIdx]);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
            }
        }
    }

    
    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_ChannelFilterCoefsGet(    adi_adrv904x_Device_t* const                        device,
                                                                    const adi_adrv904x_CarrierFilterApplicationType_e   carrierChannelFilterApplicationSel,
                                                                    const adi_adrv904x_CarrierCfg_t* const              carrierCfg,
                                                                    const int16_t** const                               coeffTable,
                                                                    int16_t* const                                      coeffTableSize,
                                                                    uint32_t* const                                     numberOfFilterTaps,
                                                                    uint8_t* const                                      assymetricFilterTaps,
                                                                    const uint8_t                                       rxFlag)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);

    if (rxFlag == ADI_TRUE)
    {
        recoveryAction = cddc_assign_coefs(device, carrierChannelFilterApplicationSel, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }
    }
    else if (rxFlag == ADI_FALSE)
    {
        recoveryAction = cduc_assign_coefs(device, carrierChannelFilterApplicationSel, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }
    }
    else
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, rxFlag, "Invalid rxFlag");
        return recoveryAction;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_5g_fs_122880_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 60000U:
            *numberOfFilterTaps = 272U;
            *assymetricFilterTaps = 0;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_122880_ibw_60000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_122880_ibw_60000) / sizeof(int16_t);
            break;

        case 70000U:
            *numberOfFilterTaps = 244U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_122880_ibw_70000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_122880_ibw_70000) / sizeof(int16_t);
            break;

        case 80000U:
            *numberOfFilterTaps = 254U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_122880_ibw_80000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_122880_ibw_80000) / sizeof(int16_t);
            break;

        case 90000U:
            *numberOfFilterTaps = 258U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_122880_ibw_90000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_122880_ibw_90000) / sizeof(int16_t);
            break;

        case 100000U:
            *numberOfFilterTaps = 267U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_122880_ibw_100000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_122880_ibw_100000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_5g_fs_15360_coefs(  adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 184U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_15360_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_15360_ibw_5000) / sizeof(int16_t);
            break;

        case 10000U:
            *numberOfFilterTaps = 77U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_15360_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_15360_ibw_10000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_5g_fs_245760_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 200000U:
            *numberOfFilterTaps = 186U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_245760_ibw_200000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_245760_ibw_200000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }
    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_5g_fs_30720_coefs(  adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 25000U:
            *numberOfFilterTaps = 89U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_30720_ibw_25000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_30720_ibw_25000) / sizeof(int16_t);
            break;

        case 5000U:
            *numberOfFilterTaps = 370U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_30720_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_30720_ibw_5000) / sizeof(int16_t);
            break;

        case 10000U:
            *numberOfFilterTaps = 278U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_30720_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_30720_ibw_10000) / sizeof(int16_t);
            break;

        case 15000U:
            *numberOfFilterTaps = 136U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_30720_ibw_15000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_30720_ibw_15000) / sizeof(int16_t);
            break;

        case 20000U:
            *numberOfFilterTaps = 124U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_30720_ibw_20000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_30720_ibw_20000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_5g_fs_491520_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 400000U:
            *numberOfFilterTaps = 186U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_491520_ibw_400000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_491520_ibw_400000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_5g_fs_61440_coefs(  adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 30000U:
            *numberOfFilterTaps = 164U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_61440_ibw_30000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_61440_ibw_30000) / sizeof(int16_t);
            break;

        case 40000U:
            *numberOfFilterTaps = 172U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_61440_ibw_40000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_61440_ibw_40000) / sizeof(int16_t);
            break;

        case 50000U:
            *numberOfFilterTaps = 151U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_61440_ibw_50000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_61440_ibw_50000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_5g_fs_7680_coefs(   adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 46U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_7680_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_7680_ibw_5000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_5g_coefs(   adi_adrv904x_Device_t* const            device,
                                                            const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                            const int16_t** const                   coeffTable,
                                                            int16_t* const                          coeffTableSize,
                                                            uint32_t* const                         numberOfFilterTaps,
                                                            uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    switch (carrierCfg->sampleRate_kHz)
    {
        case 122880U:
            recoveryAction = cddc_assign_app_5g_fs_122880_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 15360U:
            recoveryAction = cddc_assign_app_5g_fs_15360_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 245760U:
            recoveryAction = cddc_assign_app_5g_fs_245760_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 30720U:
            recoveryAction = cddc_assign_app_5g_fs_30720_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 491520U:
            recoveryAction = cddc_assign_app_5g_fs_491520_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 61440U:
            recoveryAction = cddc_assign_app_5g_fs_61440_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 7680U:
            recoveryAction = cddc_assign_app_5g_fs_7680_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->sampleRate_kHz, "Unsupported Sample Rate");
            return recoveryAction;
            break;
    }

    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_high_bw_5g_fs_122880_coefs( adi_adrv904x_Device_t* const            device,
                                                                            const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                            const int16_t** const                   coeffTable,
                                                                            int16_t* const                          coeffTableSize,
                                                                            uint32_t* const                         numberOfFilterTaps,
                                                                            uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 60000U:
            *numberOfFilterTaps = 249U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_high_bw_5g_fs_122880_ibw_60000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_high_bw_5g_fs_122880_ibw_60000) / sizeof(int16_t);
            break;

        case 100000U:
            *numberOfFilterTaps = 255U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_high_bw_5g_fs_122880_ibw_100000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_high_bw_5g_fs_122880_ibw_100000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_high_bw_5g_coefs(   adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    switch (carrierCfg->sampleRate_kHz)
    {
        case 122880U:
            recoveryAction = cddc_assign_app_high_bw_5g_fs_122880_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->sampleRate_kHz, "Unsupported Sample Rate");
            return recoveryAction;
            break;
    }

    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_lte_fs_15360_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 215;
            *assymetricFilterTaps = 0;
            *coeffTable = &adrv904x_cddc_coefs_lte_fs_15360_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_lte_fs_15360_ibw_5000) / sizeof(int16_t);
            break;

        case 10000U:
            *numberOfFilterTaps = 71;
            *assymetricFilterTaps = 0;
            *coeffTable = &adrv904x_cddc_coefs_lte_fs_15360_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_lte_fs_15360_ibw_10000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_lte_fs_30720_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 490U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_lte_fs_30720_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_lte_fs_30720_ibw_5000) / sizeof(int16_t);
            break;

        case 10000U:
            *numberOfFilterTaps = 210U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_lte_fs_30720_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_lte_fs_30720_ibw_10000) / sizeof(int16_t);
            break;

        case 15000U:
            *numberOfFilterTaps = 108U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_lte_fs_30720_ibw_15000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_lte_fs_30720_ibw_15000) / sizeof(int16_t);
            break;

        case 20000U:
            *numberOfFilterTaps = 85U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_lte_fs_30720_ibw_20000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_lte_fs_30720_ibw_20000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_lte_fs_7680_coefs(  adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 53U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_lte_fs_7680_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_lte_fs_7680_ibw_5000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_lte_coefs(  adi_adrv904x_Device_t* const            device,
                                                            const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                            const int16_t** const                   coeffTable,
                                                            int16_t* const                          coeffTableSize,
                                                            uint32_t* const                         numberOfFilterTaps,
                                                            uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    switch (carrierCfg->sampleRate_kHz)
    {
        case 15360U:
            recoveryAction = cddc_assign_app_lte_fs_15360_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 30720U:
            recoveryAction = cddc_assign_app_lte_fs_30720_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 7680U:
            recoveryAction = cddc_assign_app_lte_fs_7680_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->sampleRate_kHz, "Unsupported Sample Rate");
            return recoveryAction;
            break;
    }

    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_lte_iot_fs_15360_coefs( adi_adrv904x_Device_t* const            device,
                                                                        const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                        const int16_t** const                   coeffTable,
                                                                        int16_t* const                          coeffTableSize,
                                                                        uint32_t* const                         numberOfFilterTaps,
                                                                        uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 10000U:
            *numberOfFilterTaps = 139U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_lte_iot_fs_15360_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_lte_iot_fs_15360_ibw_10000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_lte_iot_fs_30720_coefs( adi_adrv904x_Device_t* const            device,
                                                                        const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                        const int16_t** const                   coeffTable,
                                                                        int16_t* const                          coeffTableSize,
                                                                        uint32_t* const                         numberOfFilterTaps,
                                                                        uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 20000U:
            *numberOfFilterTaps = 125U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_lte_iot_fs_30720_ibw_20000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_lte_iot_fs_30720_ibw_20000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_lte_iot_coefs(  adi_adrv904x_Device_t* const            device,
                                                                const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                const int16_t** const                   coeffTable,
                                                                int16_t* const                          coeffTableSize,
                                                                uint32_t* const                         numberOfFilterTaps,
                                                                uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->sampleRate_kHz)
    {
        case 15360U:
            recoveryAction = cddc_assign_app_lte_iot_fs_15360_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 30720U:
            recoveryAction = cddc_assign_app_lte_iot_fs_30720_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_5g_fs_122880_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 60000U:
            *numberOfFilterTaps = 279U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_122880_ibw_60000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_122880_ibw_60000) / sizeof(int16_t);
            break;

        case 70000U:
            *numberOfFilterTaps = 240U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_122880_ibw_70000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_122880_ibw_70000) / sizeof(int16_t);
            break;

        case 80000U:
            *numberOfFilterTaps = 252U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_122880_ibw_80000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_122880_ibw_80000) / sizeof(int16_t);
            break;

        case 90000U:
            *numberOfFilterTaps = 262U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_122880_ibw_90000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_122880_ibw_90000) / sizeof(int16_t);
            break;

        case 100000U:
            *numberOfFilterTaps = 277U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_122880_ibw_100000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_122880_ibw_100000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_5g_fs_15360_coefs(  adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 138U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_15360_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_15360_ibw_5000) / sizeof(int16_t);
            break;

        case 10000U:
            *numberOfFilterTaps = 92U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_15360_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_15360_ibw_10000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_5g_fs_245760_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 200000U:
            *numberOfFilterTaps = 182U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_245760_ibw_200000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_245760_ibw_200000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_5g_fs_30720_coefs(  adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 25000U:
            *numberOfFilterTaps = 113U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_30720_ibw_25000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_30720_ibw_25000) / sizeof(int16_t);
            break;

        case 5000U:
            *numberOfFilterTaps = 276U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_30720_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_30720_ibw_5000) / sizeof(int16_t);
            break;

        case 10000U:
            *numberOfFilterTaps = 208U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_30720_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_30720_ibw_10000) / sizeof(int16_t);
            break;

        case 15000U:
            *numberOfFilterTaps = 150U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_30720_ibw_15000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_30720_ibw_15000) / sizeof(int16_t);
            break;

        case 20000U:
            *numberOfFilterTaps = 129U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_30720_ibw_20000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_30720_ibw_20000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_5g_fs_491520_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 400000U:
            *numberOfFilterTaps = 182U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_491520_ibw_400000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_491520_ibw_400000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_5g_fs_61440_coefs(  adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 30000U:
            *numberOfFilterTaps = 195U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_61440_ibw_30000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_61440_ibw_30000) / sizeof(int16_t);
            break;

        case 40000U:
            *numberOfFilterTaps = 211U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_61440_ibw_40000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_61440_ibw_40000) / sizeof(int16_t);
            break;

        case 50000U:
            *numberOfFilterTaps = 170U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_61440_ibw_50000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_61440_ibw_50000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_5g_fs_7680_coefs(   adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 62U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_7680_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_7680_ibw_5000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_5g_coefs(   adi_adrv904x_Device_t* const            device,
                                                            const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                            const int16_t** const                   coeffTable,
                                                            int16_t* const                          coeffTableSize,
                                                            uint32_t* const                         numberOfFilterTaps,
                                                            uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    switch (carrierCfg->sampleRate_kHz)
    {
        case 122880U:
            recoveryAction = cduc_assign_app_5g_fs_122880_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 15360U:
            recoveryAction = cduc_assign_app_5g_fs_15360_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 245760U:
            recoveryAction = cduc_assign_app_5g_fs_245760_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 30720U:
            recoveryAction = cduc_assign_app_5g_fs_30720_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 491520U:
            recoveryAction = cduc_assign_app_5g_fs_491520_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 61440U:
            recoveryAction = cduc_assign_app_5g_fs_61440_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 7680U:
            recoveryAction = cduc_assign_app_5g_fs_7680_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->sampleRate_kHz, "Unsupported Sample Rate");
            return recoveryAction;
            break;
    }

    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_high_bw_5g_fs_122880_coefs( adi_adrv904x_Device_t* const            device,
                                                                            const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                            const int16_t** const                   coeffTable,
                                                                            int16_t* const                          coeffTableSize,
                                                                            uint32_t* const                         numberOfFilterTaps,
                                                                            uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 60000U:
            *numberOfFilterTaps = 253U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_high_bw_5g_fs_122880_ibw_60000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_high_bw_5g_fs_122880_ibw_60000) / sizeof(int16_t);
            break;

        case 100000U:
            *numberOfFilterTaps = 256U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_high_bw_5g_fs_122880_ibw_100000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_high_bw_5g_fs_122880_ibw_100000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_high_bw_5g_coefs(   adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    switch (carrierCfg->sampleRate_kHz)
    {
        case 122880U:
            recoveryAction = cduc_assign_app_high_bw_5g_fs_122880_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->sampleRate_kHz, "Unsupported Sample Rate");
            return recoveryAction;
            break;
    }

    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_lte_fs_15360_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 171U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_lte_fs_15360_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_lte_fs_15360_ibw_5000) / sizeof(int16_t);
            break;

        case 10000U:
            *numberOfFilterTaps = 66U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_lte_fs_15360_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_lte_fs_15360_ibw_10000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_lte_fs_30720_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 344U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_lte_fs_30720_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_lte_fs_30720_ibw_5000) / sizeof(int16_t);
            break;

        case 10000U:
            *numberOfFilterTaps = 170U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_lte_fs_30720_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_lte_fs_30720_ibw_10000) / sizeof(int16_t);
            break;

        case 15000U:
            *numberOfFilterTaps = 88U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_lte_fs_30720_ibw_15000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_lte_fs_30720_ibw_15000) / sizeof(int16_t);
            break;

        case 20000U:
            *numberOfFilterTaps = 66U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_lte_fs_30720_ibw_20000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_lte_fs_30720_ibw_20000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_lte_fs_7680_coefs(  adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 66U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_lte_fs_7680_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_lte_fs_7680_ibw_5000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_lte_coefs(  adi_adrv904x_Device_t* const            device,
                                                            const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                            const int16_t** const                   coeffTable,
                                                            int16_t* const                          coeffTableSize,
                                                            uint32_t* const                         numberOfFilterTaps,
                                                            uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    switch (carrierCfg->sampleRate_kHz)
    {
        case 15360U:
            recoveryAction = cduc_assign_app_lte_fs_15360_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 30720U:
            recoveryAction = cduc_assign_app_lte_fs_30720_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 7680U:
            recoveryAction = cduc_assign_app_lte_fs_7680_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->sampleRate_kHz, "Unsupported Sample Rate");
            return recoveryAction;
            break;
    }

    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_lte_iot_fs_15360_coefs( adi_adrv904x_Device_t* const            device,
                                                                        const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                        const int16_t** const                   coeffTable,
                                                                        int16_t* const                          coeffTableSize,
                                                                        uint32_t* const                         numberOfFilterTaps,
                                                                        uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 10000U:
            *numberOfFilterTaps = 241U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_lte_iot_fs_15360_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_lte_iot_fs_15360_ibw_10000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_lte_iot_fs_30720_coefs( adi_adrv904x_Device_t* const            device,
                                                                        const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                        const int16_t** const                   coeffTable,
                                                                        int16_t* const                          coeffTableSize,
                                                                        uint32_t* const                         numberOfFilterTaps,
                                                                        uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    switch (carrierCfg->ibw_kHz)
    {
        case 20000U:
            *numberOfFilterTaps = 158U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_lte_iot_fs_30720_ibw_20000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_lte_iot_fs_30720_ibw_20000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_lte_iot_coefs(  adi_adrv904x_Device_t* const            device,
                                                                const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                const int16_t** const                   coeffTable,
                                                                int16_t* const                          coeffTableSize,
                                                                uint32_t* const                         numberOfFilterTaps,
                                                                uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    switch (carrierCfg->sampleRate_kHz)
    {
        case 15360U:
            recoveryAction = cduc_assign_app_lte_iot_fs_15360_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 30720U:
            recoveryAction = cduc_assign_app_lte_iot_fs_30720_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->sampleRate_kHz, "Unsupported Sample Rate");
            return recoveryAction;
            break;
    }

    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_coefs(  adi_adrv904x_Device_t* const                        device,
                                                    const adi_adrv904x_CarrierFilterApplicationType_e   carrierChannelFilterApplicationSel,
                                                    const adi_adrv904x_CarrierCfg_t* const              carrierCfg,
                                                    const int16_t** const                               coeffTable,
                                                    int16_t* const                                      coeffTableSize,
                                                    uint32_t* const                                     numberOfFilterTaps,
                                                    uint8_t* const                                      assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    switch (carrierChannelFilterApplicationSel)
    {
        case ADI_ADRV904X_CARRIER_FILTER_5G:
            recoveryAction = cddc_assign_app_5g_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case ADI_ADRV904X_CARRIER_FILTER_HIGH_BW_5G:
            recoveryAction = cddc_assign_app_high_bw_5g_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case ADI_ADRV904X_CARRIER_FILTER_LTE:
            recoveryAction = cddc_assign_app_lte_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case ADI_ADRV904X_CARRIER_FILTER_LTE_IOT:
            recoveryAction = cddc_assign_app_lte_iot_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierChannelFilterApplicationSel, "Unsupported Carrier Channel Filter Application Select");
            return recoveryAction;
            break;
    }

    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_coefs(  adi_adrv904x_Device_t* const                        device,
                                                    const adi_adrv904x_CarrierFilterApplicationType_e   carrierChannelFilterApplicationSel,
                                                    const adi_adrv904x_CarrierCfg_t* const              carrierCfg,
                                                    const int16_t** const                               coeffTable,
                                                    int16_t* const                                      coeffTableSize,
                                                    uint32_t* const                                     numberOfFilterTaps,
                                                    uint8_t* const                                      assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    switch (carrierChannelFilterApplicationSel)
    {
        case ADI_ADRV904X_CARRIER_FILTER_5G:
            recoveryAction = cduc_assign_app_5g_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case ADI_ADRV904X_CARRIER_FILTER_HIGH_BW_5G:
            recoveryAction = cduc_assign_app_high_bw_5g_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case ADI_ADRV904X_CARRIER_FILTER_LTE:
            recoveryAction = cduc_assign_app_lte_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case ADI_ADRV904X_CARRIER_FILTER_LTE_IOT:
            recoveryAction = cduc_assign_app_lte_iot_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierChannelFilterApplicationSel, "Unsupported Carrier Channel Filter Application Select");
            return recoveryAction;
            break;
    }

    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    return recoveryAction;
}
